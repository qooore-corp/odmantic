{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ODMantic Documentation : https://art049.github.io/odmantic/ Asynchronous ODM (Object Document Mapper) for MongoDB based on standard python type hints. It's built on top of pydantic for model definition and validation. Core features: Simple : define your model by typing your fields using python types, build queries using python comparison operators Developer experience : field/method autocompletion, type hints, data validation, perform database operations with a functional API Fully typed : leverage static analysis to reduce runtime issues AsyncIO : works well with ASGI frameworks ( FastAPI , quart , sanic , Starlette , ...) Serialization : built in JSON serialization and JSON schema generation Requirements \u00b6 Python : 3.6.1 and later (tested against 3.6, 3.7, 3.8 and 3.9) MongoDB : 4.0 and later Two direct dependencies: pydantic ( >=1.6.2 ): makes data validation and schema definition both handy and elegant. motor ( >=2.1.0 ): an asyncio MongoDB driver officially developed by the MongoDB team. Installation \u00b6 pip install odmantic Example \u00b6 To enjoy an async context without any code boilerplate, you can reproduce the following steps using the AsyncIO REPL (only for Python 3.8+). python3.8 -m asyncio If you are using an earlier version of Python you can use IPython which provide an Autoawait feature (starting from Python 3.6). Define your first model \u00b6 from typing import Optional from odmantic import Field , Model class Publisher ( Model ): name : str founded : int = Field ( ge = 1440 ) location : Optional [ str ] = None By defining the Publisher class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers. This model contains three fields: name : This is the name of the Publisher. This is a simple string field without any specific validation but it will be required to build a new Publisher. founded : This is the year of foundation of the Publisher. Since the printing press has been invented in 1440, it would be handy to allow only values above 1440. The ge keyword argument passed to the Field is exactly doing this. The model will require a founded value greater or equal than 1440. location : This field will contain the country code of the Publisher. Defining this field as Optional with a None default value makes it a non required field that will be set automatically when not specified. The collection name has been defined by ODMantic as well. In this case it will be publisher . Create some instances \u00b6 instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] We defined three instances of the Publisher model. They all have a name property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to None (it will be stored as null in the database). For now, those instances only exists locally. We will persist them in a database in the next step. Populate the database with your instances \u00b6 For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container). docker run --rm -p 27017 :27017 mongo First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object. from odmantic import AIOEngine engine = AIOEngine () By default, the AIOEngine (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named test by default. The next step is to persist the instances we created before. We can perform this operation using the AIOEngine.save_all method. await engine . save_all ( instances ) Most of the engine I/O methods are asynchronous, hence the await keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface. Another possibility is to use mongo CLI directly: mongo --eval \"db.publisher.find({})\" Output: co nne c t i n g t o : mo n godb : //127.0.0.1:27017 { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54c9\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" }, { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54ca\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" }, { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : null , \"name\" : \"Lulu\" } The created instances are stored in the test database under the publisher collection. We can see that an _id field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name id . print ( instances [ 0 ] . id ) #> ObjectId(\"5f67b331514d6855bc5c54c9\") Find instances matching a criteria \u00b6 Since we now have some documents in the database, we can start building some queries. First, let's find publishers created before the 2000s: early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] Here, we called the engine.find method. The first argument we need to specify is the Model class we want to query on (in our case Publisher ). The second argument is the actual query. Similarly to SQLAlchemy , you can build ODMantic queries using the regular python operators. When awaited, the engine.find method will return the list of matching instances stored in the database. Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA): ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Here the result is None because no matching instances have been found in the database. The engine.find_one method returns an instance if one exists in the database otherwise, it will return None . Modify an instance \u00b6 Finally, let's edit some instances. For example, we can set the location for the publisher named Lulu . First, we need to gather the instance from the database: lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=None) We still have the same instance, with no location set. We can change this field: lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) The location has been changed locally but the last step to persist this change is to save the document: await engine . save ( lulu ) We can now check the database state: mongo --eval \"db.publisher.find({name: 'Lulu'})\" Output: co nne c t i n g t o : mo n godb : //127.0.0.1:27017 { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : \"US\" , \"name\" : \"Lulu\" } The document have been successfully updated ! Now, what if we would like to change the foundation date with an invalid one (before 1440) ? lulu . founded = 1000 #> ValidationError: 1 validation error for Publisher #> founded #> ensure this value is greater than 1440 #> (type=value_error.number.not_gt; limit_value=1440) This will raise an exception as it's not matching the model definition. The raised exception is actually a ValidationError created by from pydantic . Next steps \u00b6 If you already have experience with Pydantic and FastAPI, the Usage with FastAPI example might be interesting for you. Otherwise, to get started on more advanced practices like relations and building more advanced queries, you can directly check the other sections of the documentation . If you wish to contribute to the project (Thank you! ), you can have a look to the Contributing section of the documentation. License \u00b6 This project is licensed under the terms of the ISC license .","title":"Overview"},{"location":"#requirements","text":"Python : 3.6.1 and later (tested against 3.6, 3.7, 3.8 and 3.9) MongoDB : 4.0 and later Two direct dependencies: pydantic ( >=1.6.2 ): makes data validation and schema definition both handy and elegant. motor ( >=2.1.0 ): an asyncio MongoDB driver officially developed by the MongoDB team.","title":"Requirements"},{"location":"#installation","text":"pip install odmantic","title":"Installation"},{"location":"#example","text":"To enjoy an async context without any code boilerplate, you can reproduce the following steps using the AsyncIO REPL (only for Python 3.8+). python3.8 -m asyncio If you are using an earlier version of Python you can use IPython which provide an Autoawait feature (starting from Python 3.6).","title":"Example"},{"location":"#define-your-first-model","text":"from typing import Optional from odmantic import Field , Model class Publisher ( Model ): name : str founded : int = Field ( ge = 1440 ) location : Optional [ str ] = None By defining the Publisher class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers. This model contains three fields: name : This is the name of the Publisher. This is a simple string field without any specific validation but it will be required to build a new Publisher. founded : This is the year of foundation of the Publisher. Since the printing press has been invented in 1440, it would be handy to allow only values above 1440. The ge keyword argument passed to the Field is exactly doing this. The model will require a founded value greater or equal than 1440. location : This field will contain the country code of the Publisher. Defining this field as Optional with a None default value makes it a non required field that will be set automatically when not specified. The collection name has been defined by ODMantic as well. In this case it will be publisher .","title":"Define your first model"},{"location":"#create-some-instances","text":"instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] We defined three instances of the Publisher model. They all have a name property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to None (it will be stored as null in the database). For now, those instances only exists locally. We will persist them in a database in the next step.","title":"Create some instances"},{"location":"#populate-the-database-with-your-instances","text":"For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container). docker run --rm -p 27017 :27017 mongo First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object. from odmantic import AIOEngine engine = AIOEngine () By default, the AIOEngine (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named test by default. The next step is to persist the instances we created before. We can perform this operation using the AIOEngine.save_all method. await engine . save_all ( instances ) Most of the engine I/O methods are asynchronous, hence the await keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface. Another possibility is to use mongo CLI directly: mongo --eval \"db.publisher.find({})\" Output: co nne c t i n g t o : mo n godb : //127.0.0.1:27017 { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54c9\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" }, { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54ca\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" }, { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : null , \"name\" : \"Lulu\" } The created instances are stored in the test database under the publisher collection. We can see that an _id field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name id . print ( instances [ 0 ] . id ) #> ObjectId(\"5f67b331514d6855bc5c54c9\")","title":"Populate the database with your instances"},{"location":"#find-instances-matching-a-criteria","text":"Since we now have some documents in the database, we can start building some queries. First, let's find publishers created before the 2000s: early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] Here, we called the engine.find method. The first argument we need to specify is the Model class we want to query on (in our case Publisher ). The second argument is the actual query. Similarly to SQLAlchemy , you can build ODMantic queries using the regular python operators. When awaited, the engine.find method will return the list of matching instances stored in the database. Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA): ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Here the result is None because no matching instances have been found in the database. The engine.find_one method returns an instance if one exists in the database otherwise, it will return None .","title":"Find instances matching a criteria"},{"location":"#modify-an-instance","text":"Finally, let's edit some instances. For example, we can set the location for the publisher named Lulu . First, we need to gather the instance from the database: lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=None) We still have the same instance, with no location set. We can change this field: lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) The location has been changed locally but the last step to persist this change is to save the document: await engine . save ( lulu ) We can now check the database state: mongo --eval \"db.publisher.find({name: 'Lulu'})\" Output: co nne c t i n g t o : mo n godb : //127.0.0.1:27017 { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : \"US\" , \"name\" : \"Lulu\" } The document have been successfully updated ! Now, what if we would like to change the foundation date with an invalid one (before 1440) ? lulu . founded = 1000 #> ValidationError: 1 validation error for Publisher #> founded #> ensure this value is greater than 1440 #> (type=value_error.number.not_gt; limit_value=1440) This will raise an exception as it's not matching the model definition. The raised exception is actually a ValidationError created by from pydantic .","title":"Modify an instance"},{"location":"#next-steps","text":"If you already have experience with Pydantic and FastAPI, the Usage with FastAPI example might be interesting for you. Otherwise, to get started on more advanced practices like relations and building more advanced queries, you can directly check the other sections of the documentation . If you wish to contribute to the project (Thank you! ), you can have a look to the Contributing section of the documentation.","title":"Next steps"},{"location":"#license","text":"This project is licensed under the terms of the ISC license .","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 0.5.0 - 2022-06-01 \u00b6 Support motor 3.0 ( #224 by @art049 ) Support pydantic 1.9.0 ( #218 by @art049 ) 0.4.0 - 2022-04-23 \u00b6 Added \u00b6 Update and copy methods: Updating multiple fields at once is now directly possible from a pydantic model or a dictionary ( feature documentation , sample use case with FastAPI ) Changing the primary field of an instance is now easier ( documentation ) Patch and copy Model instances ( #39 by @art049 ) Fixed \u00b6 Update example in README ( #192 by @jasper-moment ) Update README.md ( #129 by @Kludex ) Internals \u00b6 \u2b06\ufe0f Update motor requirement from >=2.1.0,<2.5.0 to >=2.1.0,<2.6.0 ( #160 by @dependabot[bot] ) \u2b06\ufe0f Update typer requirement from ^0.3.2 to ^0.4.1 ( #214 by @dependabot[bot] ) \u2b06\ufe0f Update mypy requirement from ^0.910 to ^0.942 ( #215 by @dependabot[bot] ) \u2b06\ufe0f Update fastapi requirement from >=0.61.1,<0.67.0 to >=0.61.1,<0.69.0 ( #166 by @dependabot[bot] ) \u2b06\ufe0f Update fastapi requirement from >=0.61.1,<0.64.0 to >=0.61.1,<0.67.0 ( #150 by @dependabot[bot] ) \u2b06\ufe0f Update mypy requirement from ^0.812 to ^0.910 ( #142 by @dependabot[bot] ) \u2b06\ufe0f Update pytest-asyncio requirement from ^0.14.0 to ^0.15.0 ( #125 by @dependabot[bot] ) \u2b06\ufe0f Update motor requirement from >=2.1.0,<2.4.0 to >=2.1.0,<2.5.0 ( #124 by @dependabot[bot] ) \u2b06\ufe0f Update importlib-metadata requirement from >=1,<4 to >=1,<5 ( #126 by @dependabot[bot] ) \u2b06\ufe0f Update pydocstyle requirement from ^5.1.1 to ^6.0.0 ( #119 by @dependabot[bot] ) \u2b06\ufe0f Update isort requirement from ~=5.7.0 to ~=5.8.0 ( #122 by @dependabot[bot] ) \u2b06\ufe0f Update flake8 requirement from ~=3.8.4 to ~=3.9.0 ( #116 by @dependabot[bot] ) 0.3.5 - 2021-05-12 \u00b6 Security \u00b6 Change allowed pydantic versions to handle CVE-2021-29510 by @art049 0.3.4 - 2021-03-04 \u00b6 Fixed \u00b6 Fix modified mark clearing on save for nested models ( #88 by @Olegt0rr ) Don't replace default field description for ObjectId ( #82 by @Olegt0rr ) Internals \u00b6 Support pydantic 1.8 ( #113 by @art049 ) Add nightly builds ( #114 by @art049 ) CI Matrix with Standalone instances, ReplicaSets and Sharded clusters ( #91 by @art049 ) Update mkdocstrings requirement from ^0.14.0 to ^0.15.0 ( #110 by @dependabot[bot] ) Update mkdocs-material requirement from ^6.0.2 to ^7.0.3 ( #111 by @dependabot[bot] ) Update mypy requirement from ^0.800 to ^0.812 ( #106 by @dependabot[bot] ) 0.3.3 - 2021-02-13 \u00b6 Fixed \u00b6 Remove bypass_document_validation save option to avoid Not Authorized errors ( #85 by @Olegt0rr ) Fix microseconds issue: use truncation instead of round ( #100 by @erny ) Add py.typed to ship typing information for mypy ( #101 by @art049 ) Fix datetime field default example value naiveness ( #103 by @art049 ) Internals \u00b6 Update pytz requirement from ^2020.1 to ^2021.1 ( #98 by @dependabot[bot] ) Update mkdocstrings requirement from ^0.13.2 to ^0.14.0 ( #92 by @dependabot[bot] ) Update mypy requirement from ^0.790 to ^0.800 ( #97 by @dependabot[bot] ) Update isort requirement from ~=5.6.4 to ~=5.7.0 ( #90 by @dependabot[bot] ) Update fastapi requirement from >=0.61.1,<0.63.0 to >=0.61.1,<0.64.0 ( #84 by @dependabot[bot] ) 0.3.2 - 2020-12-15 \u00b6 Added \u00b6 Fix embedded model field update ( #77 by @art049 ) Fix datetime bson inheritance issue ( #78 by @Olegt0rr ) Internals \u00b6 Migrate to the updated prettier precommit hook ( #74 by @art049 ) Fix tox dependency install ( #72 by @art049 ) Update uvicorn requirement from ^0.12.1 to ^0.13.0 ( #67 by @dependabot[bot] ) Update mypy requirement from ^0.782 to ^0.790 ( #48 by @dependabot[bot] ) Update importlib-metadata requirement from ^1.0 to >=1,<4 ( #54 by @dependabot[bot] ) Update flake8 requirement from ==3.8.3 to ==3.8.4 ( #47 by @dependabot[bot] ) Update fastapi requirement from ^0.61.1 to >=0.61.1,<0.63.0 ( #59 by @dependabot[bot] ) 0.3.1 - 2020-11-16 \u00b6 Added \u00b6 Add schema_extra config option ( #41 by @art049 ) Fixed \u00b6 Fix setattr error on a manually initialized EmbeddedModel ( #40 by @art049 ) 0.3.0 - 2020-11-09 \u00b6 Deprecated \u00b6 Deprecate usage of __collection__ to customize the collection name. Prefer the collection Config option ( more details ) Added \u00b6 Allow parsing document with unset fields defaults ( documentation ) ( #28 by @art049 ) Integration with Pydantic Config class ( #37 by @art049 ): It's now possible to define custom json_encoders on the Models Some other Config options provided by Pydantic are now available ( more details ) Support CPython 3.9 ( #32 by @art049 ) Unpin pydantic to support 1.7.0 ( #29 by @art049 ) 0.2.1 - 2020-10-25 \u00b6 Fixed \u00b6 Fix combined use of skip and limit with engine.find ( #25 by @art049 ) 0.2.0 - 2020-10-25 \u00b6 Deprecated \u00b6 Deprecate AIOEngineDependency to prefer a global engine object, more details ( #21 by @art049 ) Added \u00b6 Add sorting support ( #17 by @adriencaccia ) Support motor 2.3.0 ( #20 by @art049 ) Fixed \u00b6 Fix FastAPI usage with References ( #19 by @art049 ) Docs \u00b6 Adding a CONTRIBUTING.md file to the root directory with link to docs ( #8 by @sanders41 ) Raw Query Usage Documentation Fix ( #10 by @adeelsohailahmed ) Update Filtering to include Bitwise Operator Warning ( #24 by @adeelsohailahmed ) 0.1.0 - 2020-10-19 \u00b6 Initial Release \u00b6","title":"Changelog"},{"location":"changelog/#changelog","text":"The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#050-2022-06-01","text":"Support motor 3.0 ( #224 by @art049 ) Support pydantic 1.9.0 ( #218 by @art049 )","title":"0.5.0 - 2022-06-01"},{"location":"changelog/#040-2022-04-23","text":"","title":"0.4.0 - 2022-04-23"},{"location":"changelog/#added","text":"Update and copy methods: Updating multiple fields at once is now directly possible from a pydantic model or a dictionary ( feature documentation , sample use case with FastAPI ) Changing the primary field of an instance is now easier ( documentation ) Patch and copy Model instances ( #39 by @art049 )","title":"Added"},{"location":"changelog/#fixed","text":"Update example in README ( #192 by @jasper-moment ) Update README.md ( #129 by @Kludex )","title":"Fixed"},{"location":"changelog/#internals","text":"\u2b06\ufe0f Update motor requirement from >=2.1.0,<2.5.0 to >=2.1.0,<2.6.0 ( #160 by @dependabot[bot] ) \u2b06\ufe0f Update typer requirement from ^0.3.2 to ^0.4.1 ( #214 by @dependabot[bot] ) \u2b06\ufe0f Update mypy requirement from ^0.910 to ^0.942 ( #215 by @dependabot[bot] ) \u2b06\ufe0f Update fastapi requirement from >=0.61.1,<0.67.0 to >=0.61.1,<0.69.0 ( #166 by @dependabot[bot] ) \u2b06\ufe0f Update fastapi requirement from >=0.61.1,<0.64.0 to >=0.61.1,<0.67.0 ( #150 by @dependabot[bot] ) \u2b06\ufe0f Update mypy requirement from ^0.812 to ^0.910 ( #142 by @dependabot[bot] ) \u2b06\ufe0f Update pytest-asyncio requirement from ^0.14.0 to ^0.15.0 ( #125 by @dependabot[bot] ) \u2b06\ufe0f Update motor requirement from >=2.1.0,<2.4.0 to >=2.1.0,<2.5.0 ( #124 by @dependabot[bot] ) \u2b06\ufe0f Update importlib-metadata requirement from >=1,<4 to >=1,<5 ( #126 by @dependabot[bot] ) \u2b06\ufe0f Update pydocstyle requirement from ^5.1.1 to ^6.0.0 ( #119 by @dependabot[bot] ) \u2b06\ufe0f Update isort requirement from ~=5.7.0 to ~=5.8.0 ( #122 by @dependabot[bot] ) \u2b06\ufe0f Update flake8 requirement from ~=3.8.4 to ~=3.9.0 ( #116 by @dependabot[bot] )","title":"Internals"},{"location":"changelog/#035-2021-05-12","text":"","title":"0.3.5 - 2021-05-12"},{"location":"changelog/#security","text":"Change allowed pydantic versions to handle CVE-2021-29510 by @art049","title":"Security"},{"location":"changelog/#034-2021-03-04","text":"","title":"0.3.4 - 2021-03-04"},{"location":"changelog/#fixed_1","text":"Fix modified mark clearing on save for nested models ( #88 by @Olegt0rr ) Don't replace default field description for ObjectId ( #82 by @Olegt0rr )","title":"Fixed"},{"location":"changelog/#internals_1","text":"Support pydantic 1.8 ( #113 by @art049 ) Add nightly builds ( #114 by @art049 ) CI Matrix with Standalone instances, ReplicaSets and Sharded clusters ( #91 by @art049 ) Update mkdocstrings requirement from ^0.14.0 to ^0.15.0 ( #110 by @dependabot[bot] ) Update mkdocs-material requirement from ^6.0.2 to ^7.0.3 ( #111 by @dependabot[bot] ) Update mypy requirement from ^0.800 to ^0.812 ( #106 by @dependabot[bot] )","title":"Internals"},{"location":"changelog/#033-2021-02-13","text":"","title":"0.3.3 - 2021-02-13"},{"location":"changelog/#fixed_2","text":"Remove bypass_document_validation save option to avoid Not Authorized errors ( #85 by @Olegt0rr ) Fix microseconds issue: use truncation instead of round ( #100 by @erny ) Add py.typed to ship typing information for mypy ( #101 by @art049 ) Fix datetime field default example value naiveness ( #103 by @art049 )","title":"Fixed"},{"location":"changelog/#internals_2","text":"Update pytz requirement from ^2020.1 to ^2021.1 ( #98 by @dependabot[bot] ) Update mkdocstrings requirement from ^0.13.2 to ^0.14.0 ( #92 by @dependabot[bot] ) Update mypy requirement from ^0.790 to ^0.800 ( #97 by @dependabot[bot] ) Update isort requirement from ~=5.6.4 to ~=5.7.0 ( #90 by @dependabot[bot] ) Update fastapi requirement from >=0.61.1,<0.63.0 to >=0.61.1,<0.64.0 ( #84 by @dependabot[bot] )","title":"Internals"},{"location":"changelog/#032-2020-12-15","text":"","title":"0.3.2 - 2020-12-15"},{"location":"changelog/#added_1","text":"Fix embedded model field update ( #77 by @art049 ) Fix datetime bson inheritance issue ( #78 by @Olegt0rr )","title":"Added"},{"location":"changelog/#internals_3","text":"Migrate to the updated prettier precommit hook ( #74 by @art049 ) Fix tox dependency install ( #72 by @art049 ) Update uvicorn requirement from ^0.12.1 to ^0.13.0 ( #67 by @dependabot[bot] ) Update mypy requirement from ^0.782 to ^0.790 ( #48 by @dependabot[bot] ) Update importlib-metadata requirement from ^1.0 to >=1,<4 ( #54 by @dependabot[bot] ) Update flake8 requirement from ==3.8.3 to ==3.8.4 ( #47 by @dependabot[bot] ) Update fastapi requirement from ^0.61.1 to >=0.61.1,<0.63.0 ( #59 by @dependabot[bot] )","title":"Internals"},{"location":"changelog/#031-2020-11-16","text":"","title":"0.3.1 - 2020-11-16"},{"location":"changelog/#added_2","text":"Add schema_extra config option ( #41 by @art049 )","title":"Added"},{"location":"changelog/#fixed_3","text":"Fix setattr error on a manually initialized EmbeddedModel ( #40 by @art049 )","title":"Fixed"},{"location":"changelog/#030-2020-11-09","text":"","title":"0.3.0 - 2020-11-09"},{"location":"changelog/#deprecated","text":"Deprecate usage of __collection__ to customize the collection name. Prefer the collection Config option ( more details )","title":"Deprecated"},{"location":"changelog/#added_3","text":"Allow parsing document with unset fields defaults ( documentation ) ( #28 by @art049 ) Integration with Pydantic Config class ( #37 by @art049 ): It's now possible to define custom json_encoders on the Models Some other Config options provided by Pydantic are now available ( more details ) Support CPython 3.9 ( #32 by @art049 ) Unpin pydantic to support 1.7.0 ( #29 by @art049 )","title":"Added"},{"location":"changelog/#021-2020-10-25","text":"","title":"0.2.1 - 2020-10-25"},{"location":"changelog/#fixed_4","text":"Fix combined use of skip and limit with engine.find ( #25 by @art049 )","title":"Fixed"},{"location":"changelog/#020-2020-10-25","text":"","title":"0.2.0 - 2020-10-25"},{"location":"changelog/#deprecated_1","text":"Deprecate AIOEngineDependency to prefer a global engine object, more details ( #21 by @art049 )","title":"Deprecated"},{"location":"changelog/#added_4","text":"Add sorting support ( #17 by @adriencaccia ) Support motor 2.3.0 ( #20 by @art049 )","title":"Added"},{"location":"changelog/#fixed_5","text":"Fix FastAPI usage with References ( #19 by @art049 )","title":"Fixed"},{"location":"changelog/#docs","text":"Adding a CONTRIBUTING.md file to the root directory with link to docs ( #8 by @sanders41 ) Raw Query Usage Documentation Fix ( #10 by @adeelsohailahmed ) Update Filtering to include Bitwise Operator Warning ( #24 by @adeelsohailahmed )","title":"Docs"},{"location":"changelog/#010-2020-10-19","text":"","title":"0.1.0 - 2020-10-19"},{"location":"changelog/#initial-release","text":"","title":"Initial Release"},{"location":"contributing/","text":"Contributing \u00b6 Sharing feedback \u00b6 This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . The easiest way to share feedback and discuss about the project is to join the Gitter chatroom . If you want to contribute (thanks a lot ! ), you can open an issue on Github. Before creating a non obvious (typo, documentation fix) Pull Request, please make sure to open an issue. Developing locally \u00b6 With the VSCode's devcontainer feature \u00b6 This feature will make the tools/environment installation very simple as you will develop in a container that has already been configured to run this project. Here are the steps: Clone the repository and open it with Visual Studio Code . Make sure that the Remote - Containers ( ms-vscode-remote.remote-containers ) extension is installed. Run the Remote-Container: Reopen in Container command (press Ctrl + Shift + P and then type the command). After the setup script completes, the environment is ready. You can start the local development . You can go to the development tasks section to see the available task commands. MongoDB container In this containerized development environment, a MongoDB instance should already be running as a part of the development docker-compose.yml file internally used by VSCode. Regular environment setup \u00b6 Installing the tools \u00b6 Git LFS : used to store documentation assets in the repository Docker : used to run a local MongoDB instance Docker Compose (Optional): used to run a local MongoDB cluster (replica set or shards) Task : task manager Installing python based development tools In order to install the devtools written in python, it's recommended to use pipx . python3 -m pip install --user pipx python3 -m pipx ensurepath Poetry : packaging system and dependency manager pipx install poetry tox : multi-environment test runner pipx install tox pre-commit : pre commit hook manager pipx install pre-commit Python versions If you want to test the project with multiple python versions, you'll need to install them manually. You can use pyenv to install them easily. # Install the versions pyenv install \"3.6.12\" pyenv install \"3.7.9\" pyenv install \"3.8.9\" pyenv install \"3.9.0\" # Make the versions available locally in the project pyenv local 3 .8.6 3 .7.9 3 .6.12 3 .9.0 Configuring the local environment \u00b6 task setup Running development tasks \u00b6 The following tasks are available for the project: task setup : Configure the development environment. task lint : Run the linting checks. task format : Format the code (and imports). mongodb:standalone-docker : Start a standalone MongoDB instance using a docker container mongodb:standalone-docker:down : Stop the standalone instance mongodb:replica-compose : Start a replica set MongoDB cluster using docker-compose mongodb:replica-compose:down : Stop the replica set cluster mongodb:sharded-compose : Start a sharded MongoDB cluster using docker-compose mongodb:sharded-compose:down : Stop the sharded MongoDB cluster task test : Run the tests with the current version. task full-test : Run the tests against all supported versions. task coverage : Get the test coverage (xml and html) with the current version. task docs : Start the local documentation server.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#sharing-feedback","text":"This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . The easiest way to share feedback and discuss about the project is to join the Gitter chatroom . If you want to contribute (thanks a lot ! ), you can open an issue on Github. Before creating a non obvious (typo, documentation fix) Pull Request, please make sure to open an issue.","title":"Sharing feedback"},{"location":"contributing/#developing-locally","text":"","title":"Developing locally"},{"location":"contributing/#with-the-vscodes-devcontainer-feature","text":"This feature will make the tools/environment installation very simple as you will develop in a container that has already been configured to run this project. Here are the steps: Clone the repository and open it with Visual Studio Code . Make sure that the Remote - Containers ( ms-vscode-remote.remote-containers ) extension is installed. Run the Remote-Container: Reopen in Container command (press Ctrl + Shift + P and then type the command). After the setup script completes, the environment is ready. You can start the local development . You can go to the development tasks section to see the available task commands. MongoDB container In this containerized development environment, a MongoDB instance should already be running as a part of the development docker-compose.yml file internally used by VSCode.","title":"With the VSCode's devcontainer feature"},{"location":"contributing/#regular-environment-setup","text":"","title":"Regular environment setup"},{"location":"contributing/#installing-the-tools","text":"Git LFS : used to store documentation assets in the repository Docker : used to run a local MongoDB instance Docker Compose (Optional): used to run a local MongoDB cluster (replica set or shards) Task : task manager Installing python based development tools In order to install the devtools written in python, it's recommended to use pipx . python3 -m pip install --user pipx python3 -m pipx ensurepath Poetry : packaging system and dependency manager pipx install poetry tox : multi-environment test runner pipx install tox pre-commit : pre commit hook manager pipx install pre-commit Python versions If you want to test the project with multiple python versions, you'll need to install them manually. You can use pyenv to install them easily. # Install the versions pyenv install \"3.6.12\" pyenv install \"3.7.9\" pyenv install \"3.8.9\" pyenv install \"3.9.0\" # Make the versions available locally in the project pyenv local 3 .8.6 3 .7.9 3 .6.12 3 .9.0","title":"Installing the tools"},{"location":"contributing/#configuring-the-local-environment","text":"task setup","title":"Configuring the local environment"},{"location":"contributing/#running-development-tasks","text":"The following tasks are available for the project: task setup : Configure the development environment. task lint : Run the linting checks. task format : Format the code (and imports). mongodb:standalone-docker : Start a standalone MongoDB instance using a docker container mongodb:standalone-docker:down : Stop the standalone instance mongodb:replica-compose : Start a replica set MongoDB cluster using docker-compose mongodb:replica-compose:down : Stop the replica set cluster mongodb:sharded-compose : Start a sharded MongoDB cluster using docker-compose mongodb:sharded-compose:down : Stop the sharded MongoDB cluster task test : Run the tests with the current version. task full-test : Run the tests against all supported versions. task coverage : Get the test coverage (xml and html) with the current version. task docs : Start the local documentation server.","title":"Running development tasks"},{"location":"engine/","text":"Engine \u00b6 Creating the engine \u00b6 In the previous examples, we created the engine using default parameters: MongoDB: running on localhost port 27017 Database name: test It's possible to provide a custom AsyncIOMotorClient to the AIOEngine constructor. In the same way, the database name can be changed using the database keyword argument. 1 2 3 4 5 6 from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , database = \"example_db\" ) For additional information about the MongoDB connection strings, see this section of the MongoDB documentation. Usage with DNS SRV records If you decide to use the DNS Seed List Connection Format (i.e mongodb+srv://... ), you will need to install the dnspython package. Create \u00b6 There are two ways of persisting instances to the database (i.e creating new documents): AIOEngine.save : to save a single instance AIOEngine.save_all : to save multiple instances at once 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) await engine . save ( leeroy ) players = [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] await engine . save_all ( players ) Resulting documents in the player collection { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Counter-Strike\" , \"name\" : \"Shroud\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Referenced instances When calling AIOEngine.save or AIOEngine.save_all , the referenced models will be persisted as well. Upsert behavior The save and save_all methods behave as upsert operations ( more details ). Hence, you might overwrite documents if you save instances with an existing primary key already existing in the database. Read \u00b6 Examples database content The next examples will consider that you have a player collection populated with the documents previously created. Fetch a single instance \u00b6 As with regular MongoDB driver, you can use the AIOEngine.find_one method to get at most one instance of a specific Model. This method will either return an instance matching the specified criteriums or None if no instances have been found. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player = await engine . find_one ( Player , Player . name == \"Serral\" ) print ( repr ( player )) #> Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\") another_player = await engine . find_one ( Player , Player . name == \"Player_Not_Stored_In_Database\" ) print ( another_player ) #> None Missing values in documents While parsing the MongoDB documents into Model instances, ODMantic will use the provided default values to populate the missing fields. See this section for more details about document parsing. Fetch using sort We can use the sort parameter to fetch the Player instance with the first name in ascending order: await engine . find_one ( Player , sort = Player . name ) Find out more on sort in the dedicated section . Fetch multiple instances \u00b6 To get more than one instance from the database at once, you can use the AIOEngine.find method. This method will return an AIOCursor object, that can be used in two different ways. Usage as an async iterator \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async for player in engine . find ( Player , Player . game == \"Starcraft\" ): print ( repr ( player )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') #> Player(id=ObjectId(...), name='Serral', game='Starcraft') Ordering instances The sort parameter allows to order the query in ascending or descending order on a single or multiple fields. engine . find ( Player , sort = ( Player . name , Player . game . desc ())) Find out more on sort in the dedicated section . Usage as an awaitable \u00b6 Even if the async iterator usage should be preferred, in some cases it might be required to gather all the documents from the database before processing them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player , Player . game != \"Starcraft\" ) print ( players ) #> [ #> Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"), #> Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"), #> ] Pagination You can as well use the skip and limit keyword arguments when using AIOEngine.find , respectively to skip a specified number of instances and to limit the number of fetched instances. Referenced instances When calling AIOEngine.find or AIOEngine.find_one , the referenced models will be recursively resolved as well. Passing the model class to find and find_one When using the method to retrieve instances from the database, you have to specify the Model you want to query on as the first positional parameter. Internally, this enables ODMantic to properly type the results. Count instances \u00b6 You can count instances in the database by using the AIOEngine.count method. It's possible as well to use this method with filtering queries. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_count = await engine . count ( Player ) print ( player_count ) #> 4 cs_count = await engine . count ( Player , Player . game == \"Counter-Strike\" ) print ( cs_count ) #> 1 valorant_count = await engine . count ( Player , Player . game == \"Valorant\" ) print ( valorant_count ) #> 0 Combining multiple queries in read operations While using find , find_one or count , you may pass as many queries as you want as positional arguments. Those will be implicitly combined as single and_ query. Update \u00b6 Updating an instance in the database can be done by modifying the instance locally and saving it again to the database. The AIOEngine.save and AIOEngine.save_all methods are actually behaving as upsert operations. In other words, if the instance already exists it will be updated. Otherwise, the related document will be created in the database. Modifying one field \u00b6 Modifying a single field can be achieved by directly changing the instance attribute and saving the instance. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . game ) #> Counter-Strike shroud . game = \"Valorant\" await engine . save ( shroud ) Resulting documents in the player collection { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Patching multiple fields at once \u00b6 The easiest way to change multiple fields at once is to use the Model.update method. This method will take either a Pydantic object or a dictionary and update the matching fields of the instance. From a Pydantic Model 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pydantic import BaseModel from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_tlo = await engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the structure of the patch object with pydantic class PatchPlayerSchema ( BaseModel ): name : str game : str # Create the patch object containing the new values patch_object = PatchPlayerSchema ( name = \"TheLittleOne\" , game = \"Starcraft II\" ) # Apply the patch to the instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist again the new instance await engine . save ( player_tlo ) From a dictionary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_tlo = await engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the patch dictionary containing the new values patch_object = { \"name\" : \"TheLittleOne\" , \"game\" : \"Starcraft II\" } # Update the local instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist the instance await engine . save ( player_tlo ) Resulting document associated to the player { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft II\" , \"name\" : \"TheLittleOne\" } Changing the primary field \u00b6 Directly changing the primary field value as explained above is not possible and a NotImplementedError exception will be raised if you try to do so. The easiest way to change an instance primary field is to perform a local copy of the instance using the Model.copy method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from bson import ObjectId from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . id ) #> 5f86074f6dfecacc68428a62 new_id = ObjectId ( \"ffffffffffffffffffffffff\" ) # Copy the player instance with a new primary key new_shroud = shroud . copy ( update = { \"id\" : new_id }) # Delete the initial player instance await engine . delete ( shroud ) # Finally persist again the new instance await engine . save ( new_shroud ) Resulting document associated to the player { \"_id\" : Objec t Id( \"ffffffffffffffffffffffff\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } Update data used with the copy The data updated by the copy method is not validated: you should absolutely trust this data. Delete \u00b6 You can delete instance by passing them to the AIOEngine.delete method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player ) for player in players : await engine . delete ( player ) The collection is now empty .","title":"Engine"},{"location":"engine/#engine","text":"","title":"Engine"},{"location":"engine/#creating-the-engine","text":"In the previous examples, we created the engine using default parameters: MongoDB: running on localhost port 27017 Database name: test It's possible to provide a custom AsyncIOMotorClient to the AIOEngine constructor. In the same way, the database name can be changed using the database keyword argument. 1 2 3 4 5 6 from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , database = \"example_db\" ) For additional information about the MongoDB connection strings, see this section of the MongoDB documentation. Usage with DNS SRV records If you decide to use the DNS Seed List Connection Format (i.e mongodb+srv://... ), you will need to install the dnspython package.","title":"Creating the engine"},{"location":"engine/#create","text":"There are two ways of persisting instances to the database (i.e creating new documents): AIOEngine.save : to save a single instance AIOEngine.save_all : to save multiple instances at once 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) await engine . save ( leeroy ) players = [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] await engine . save_all ( players ) Resulting documents in the player collection { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Counter-Strike\" , \"name\" : \"Shroud\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Referenced instances When calling AIOEngine.save or AIOEngine.save_all , the referenced models will be persisted as well. Upsert behavior The save and save_all methods behave as upsert operations ( more details ). Hence, you might overwrite documents if you save instances with an existing primary key already existing in the database.","title":"Create"},{"location":"engine/#read","text":"Examples database content The next examples will consider that you have a player collection populated with the documents previously created.","title":"Read"},{"location":"engine/#fetch-a-single-instance","text":"As with regular MongoDB driver, you can use the AIOEngine.find_one method to get at most one instance of a specific Model. This method will either return an instance matching the specified criteriums or None if no instances have been found. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player = await engine . find_one ( Player , Player . name == \"Serral\" ) print ( repr ( player )) #> Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\") another_player = await engine . find_one ( Player , Player . name == \"Player_Not_Stored_In_Database\" ) print ( another_player ) #> None Missing values in documents While parsing the MongoDB documents into Model instances, ODMantic will use the provided default values to populate the missing fields. See this section for more details about document parsing. Fetch using sort We can use the sort parameter to fetch the Player instance with the first name in ascending order: await engine . find_one ( Player , sort = Player . name ) Find out more on sort in the dedicated section .","title":"Fetch a single instance"},{"location":"engine/#fetch-multiple-instances","text":"To get more than one instance from the database at once, you can use the AIOEngine.find method. This method will return an AIOCursor object, that can be used in two different ways.","title":"Fetch multiple instances"},{"location":"engine/#usage-as-an-async-iterator","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async for player in engine . find ( Player , Player . game == \"Starcraft\" ): print ( repr ( player )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') #> Player(id=ObjectId(...), name='Serral', game='Starcraft') Ordering instances The sort parameter allows to order the query in ascending or descending order on a single or multiple fields. engine . find ( Player , sort = ( Player . name , Player . game . desc ())) Find out more on sort in the dedicated section .","title":"Usage as an async iterator"},{"location":"engine/#usage-as-an-awaitable","text":"Even if the async iterator usage should be preferred, in some cases it might be required to gather all the documents from the database before processing them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player , Player . game != \"Starcraft\" ) print ( players ) #> [ #> Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"), #> Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"), #> ] Pagination You can as well use the skip and limit keyword arguments when using AIOEngine.find , respectively to skip a specified number of instances and to limit the number of fetched instances. Referenced instances When calling AIOEngine.find or AIOEngine.find_one , the referenced models will be recursively resolved as well. Passing the model class to find and find_one When using the method to retrieve instances from the database, you have to specify the Model you want to query on as the first positional parameter. Internally, this enables ODMantic to properly type the results.","title":"Usage as an awaitable"},{"location":"engine/#count-instances","text":"You can count instances in the database by using the AIOEngine.count method. It's possible as well to use this method with filtering queries. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_count = await engine . count ( Player ) print ( player_count ) #> 4 cs_count = await engine . count ( Player , Player . game == \"Counter-Strike\" ) print ( cs_count ) #> 1 valorant_count = await engine . count ( Player , Player . game == \"Valorant\" ) print ( valorant_count ) #> 0 Combining multiple queries in read operations While using find , find_one or count , you may pass as many queries as you want as positional arguments. Those will be implicitly combined as single and_ query.","title":"Count instances"},{"location":"engine/#update","text":"Updating an instance in the database can be done by modifying the instance locally and saving it again to the database. The AIOEngine.save and AIOEngine.save_all methods are actually behaving as upsert operations. In other words, if the instance already exists it will be updated. Otherwise, the related document will be created in the database.","title":"Update"},{"location":"engine/#modifying-one-field","text":"Modifying a single field can be achieved by directly changing the instance attribute and saving the instance. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . game ) #> Counter-Strike shroud . game = \"Valorant\" await engine . save ( shroud ) Resulting documents in the player collection { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" }","title":"Modifying one field"},{"location":"engine/#patching-multiple-fields-at-once","text":"The easiest way to change multiple fields at once is to use the Model.update method. This method will take either a Pydantic object or a dictionary and update the matching fields of the instance. From a Pydantic Model 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pydantic import BaseModel from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_tlo = await engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the structure of the patch object with pydantic class PatchPlayerSchema ( BaseModel ): name : str game : str # Create the patch object containing the new values patch_object = PatchPlayerSchema ( name = \"TheLittleOne\" , game = \"Starcraft II\" ) # Apply the patch to the instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist again the new instance await engine . save ( player_tlo ) From a dictionary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_tlo = await engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the patch dictionary containing the new values patch_object = { \"name\" : \"TheLittleOne\" , \"game\" : \"Starcraft II\" } # Update the local instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist the instance await engine . save ( player_tlo ) Resulting document associated to the player { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft II\" , \"name\" : \"TheLittleOne\" }","title":"Patching multiple fields at once"},{"location":"engine/#changing-the-primary-field","text":"Directly changing the primary field value as explained above is not possible and a NotImplementedError exception will be raised if you try to do so. The easiest way to change an instance primary field is to perform a local copy of the instance using the Model.copy method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from bson import ObjectId from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . id ) #> 5f86074f6dfecacc68428a62 new_id = ObjectId ( \"ffffffffffffffffffffffff\" ) # Copy the player instance with a new primary key new_shroud = shroud . copy ( update = { \"id\" : new_id }) # Delete the initial player instance await engine . delete ( shroud ) # Finally persist again the new instance await engine . save ( new_shroud ) Resulting document associated to the player { \"_id\" : Objec t Id( \"ffffffffffffffffffffffff\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } Update data used with the copy The data updated by the copy method is not validated: you should absolutely trust this data.","title":"Changing the primary field"},{"location":"engine/#delete","text":"You can delete instance by passing them to the AIOEngine.delete method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player ) for player in players : await engine . delete ( player ) The collection is now empty .","title":"Delete"},{"location":"fields/","text":"Fields \u00b6 The id field \u00b6 The ObjectId data type is the default primary key type used by MongoDB. An ObjectId comes with many information embedded into it (timestamp, machine identifier, ...). Since by default MongoDB will create a field _id containing an ObjectId primary key, ODMantic will bind it automatically to an implicit field named id . 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( leeroy . id ) #> ObjectId('5ed50fcad11d1975aa3d7a28') print ( repr ( leeroy )) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\") ObjectId creation This id field will be generated on instance creation, before saving the instance to the database. This helps to keep consistency between the instances persisted to the database and the ones only created locally. Even if this behavior is convenient, it is still possible to define custom primary keys . Field types \u00b6 Optional fields \u00b6 By default, every single field will be required. To specify a field as non-required, the easiest way is to use the typing.Optional generic type that will allow the field to take the None value as well (it will be stored as null in the database). 1 2 3 4 5 6 7 8 9 10 11 12 from typing import Optional from odmantic import Model class Person ( Model ): name : str age : Optional [ int ] john = Person ( name = \"John\" ) print ( john . age ) #> None Union fields \u00b6 As explained in the Python Typing documentation , Optional[X] is equivalent to Union[X, None] . That implies that the field type will be either X or None . It's possible to combine any kind of type using the typ\u00eeng.Union type constructor. For example if we want to allow both string and int in a field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from typing import Union from odmantic import Model class Thing ( Model ): ref_id : Union [ int , str ] thing_1 = Thing ( ref_id = 42 ) print ( thing_1 . ref_id ) #> 42 thing_2 = Thing ( ref_id = \"i am a string\" ) print ( thing_2 . ref_id ) #> i am a string NoneType Internally python describes the type of the None object as NoneType but in practice, None is used directly in type annotations ( more details ). Enum fields \u00b6 To define choices, it's possible to use the standard enum classes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from enum import Enum from odmantic import AIOEngine , Model class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str kind : TreeKind sequoia = Tree ( name = \"Sequoia\" , kind = TreeKind . BIG ) print ( sequoia . kind ) #> TreeKind.BIG print ( sequoia . kind == \"big\" ) #> True spruce = Tree ( name = \"Spruce\" , kind = \"small\" ) print ( spruce . kind ) #> TreeKind.SMALL print ( spruce . kind == TreeKind . SMALL ) #> True engine = AIOEngine () await engine . save_all ([ sequoia , spruce ]) Resulting documents in the collection tree after execution { \"_id\" : Objec t Id( \"5f818f2dd5708527282c49b6\" ) , \"kind\" : \"big\" , \"name\" : \"Sequoia\" } { \"_id\" : Objec t Id( \"5f818f2dd5708527282c49b7\" ) , \"kind\" : \"small\" , \"name\" : \"Spruce\" } If you try to use a value not present in the allowed choices, a ValidationError exception will be raised. Usage of enum.auto If you might add some values to an Enum , it's strongly recommended not to use the enum.auto value generator. Depending on the order you add choices, it could completely break the consistency with documents stored in the database. Unwanted behavior example 1 2 3 4 5 6 7 8 9 10 11 12 from enum import Enum , auto class Color ( Enum ): RED = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . BLUE . value ) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from enum import Enum , auto class Color ( Enum ): RED = auto () GREEN = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . GREEN . value ) #> 2 print ( Color . BLUE . value ) #> 3 Container fields \u00b6 List \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import List , Union from odmantic import Model class SimpleListModel ( Model ): field : list print ( SimpleListModel ( field = [ 1 , \"a\" , True ]) . field ) #> [1, 'a', True] print ( SimpleListModel ( field = ( 1 , \"a\" , True )) . field ) #> [1, 'a', True] class IntListModel ( Model ): field : List [ int ] print ( IntListModel ( field = [ 1 , 5 ]) . field ) #> [1, 5] print ( IntListModel ( field = ( 1 , 5 )) . field ) #> [1, 5] class IntStrListModel ( Model ): field : List [ Union [ int , str ]] print ( IntStrListModel ( field = [ 1 , \"b\" ]) . field ) #> [1, 'b'] print ( IntStrListModel ( field = ( 1 , \"b\" )) . field ) #> [1, 'b'] Tip It's possible to define element count constraints for a list field using the Field descriptor. Tuple \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import Tuple from odmantic import Model class SimpleTupleModel ( Model ): field : tuple print ( SimpleTupleModel ( field = [ 1 , \"a\" , True ]) . field ) #> (1, 'a', True) print ( SimpleTupleModel ( field = ( 1 , \"a\" , True )) . field ) #> (1, 'a', True) class TwoIntTupleModel ( Model ): field : Tuple [ int , int ] print ( SimpleTupleModel ( field = ( 1 , 10 )) . field ) #> (1, 10) print ( SimpleTupleModel ( field = [ 1 , 10 ]) . field ) #> (1, 10) class IntTupleModel ( Model ): field : Tuple [ int , ... ] print ( IntTupleModel ( field = ( 1 ,)) . field ) #> (1,) print ( IntTupleModel ( field = [ 1 , 2 , 3 , 10 ]) . field ) #> (1, 2, 3, 10) Dict \u00b6 Tip For mapping types with already known keys, you can see the embedded models section . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from typing import Dict , Union from odmantic import Model class SimpleDictModel ( Model ): field : dict print ( SimpleDictModel ( field = { 18 : \"a string\" , True : 42 , 18.3 : [ 1 , 2 , 3 ]}) . field ) #> {18: 'a string', True: 42, 18.3: [1, 2, 3]} class IntStrDictModel ( Model ): field : Dict [ int , str ] print ( IntStrDictModel ( field = { 1 : \"one\" , 2 : \"two\" }) . field ) #> {1: 'one', 2: 'two'} class IntBoolStrDictModel ( Model ): field : Dict [ int , Union [ bool , str ]] print ( IntBoolStrDictModel ( field = { 0 : False , 1 : True , 3 : \"three\" }) . field ) #> {0: False, 1: True, 3: 'three'} Performance tip Whenever possible, try to avoid mutable container types ( List , Set , ...) and prefer their Immutable alternatives ( Tuple , FrozenSet , ...). This will allow ODMantic to speedup database writes by only saving the modified container fields. BSON types integration \u00b6 ODMantic supports native python BSON types ( bson package ). Those types can be used directly as field types: bson.ObjectId bson.Int64 bson.Decimal128 bson.Regex bson.Binary Generic python to BSON type map Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal decimal str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array Pydantic fields \u00b6 Most of the types supported by pydantic are supported by ODMantic. See pydantic: Field Types for more field types. Unsupported fields: typing.Callable Fields with a specific behavior: datetime.datetime : Only naive datetime objects will be allowed as MongoDB doesn't store the timezone information. Also, the microsecond information will be truncated. Customization \u00b6 The field customization can mainly be performed using the Field descriptor. This descriptor is here to define everything about the field except its type. Default values \u00b6 The easiest way to set a default value to a field is by assigning this default value directly while defining the model. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cd4be16af832772f1615e'), name='Dash', level=0) You can combine default values and an existing Field descriptor using the default keyword argument. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Field , Model class Player ( Model ): name : str level : int = Field ( default = 1 , ge = 1 ) p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cdbfbb54a94e9e8717c77'), name='Dash', level=1) Default factory You may as well define a factory function instead of a value using the default_factory argument of the Field descriptor. By default, the default factories won't be used while parsing MongoDB documents. It's possible to enable this behavior with the parse_doc_with_default_factories Config option. Tip For typing.Optional fields, None is already set as the default value Default values validation Currently the default values are not validated yet during the model creation. An inconsistent default value might raise a ValidationError while building an instance. Document structure \u00b6 By default, the MongoDB documents fields will be named after the field name. It is possible to override this naming policy by using the key_name argument in the Field descriptor. 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( key_name = \"username\" ) engine = AIOEngine () await engine . save ( Player ( name = \"Jack\" )) Resulting documents in the collection player after execution { \"_id\" : Objec t Id( \"5ed50fcad11d1975aa3d7a28\" ) , \"username\" : \"Jack\" , } See this section for more details about the _id field that has been added. Primary key \u00b6 While ODMantic will by default populate the id field as a primary key, you can use any other field as the primary key. 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( repr ( leeroy )) #> Player(name=\"Leeroy Jenkins\") engine = AIOEngine () await engine . save ( leeroy ) Resulting documents in the collection player after execution { \"_id\" : \"Leeroy Jenkins\" } Info The Mongo name of the primary field will be enforced to _id and you will not be able to change it. Warning Using mutable types (Set, List, ...) as primary field might result in inconsistent behaviors. Validation \u00b6 As ODMantic strongly relies on pydantic when it comes to data validation, most of the validation features provided by pydantic are available: Add field validation constraints by using the Field descriptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from typing import List from odmantic import Field , Model class ExampleModel ( Model ): small_int : int = Field ( le = 10 ) big_int : int = Field ( gt = 1000 ) even_int : int = Field ( multiple_of = 2 ) small_float : float = Field ( lt = 10 ) big_float : float = Field ( ge = 1e10 ) short_string : str = Field ( max_length = 10 ) long_string : str = Field ( min_length = 100 ) string_starting_with_the : str = Field ( regex = r \"^The\" ) short_str_list : List [ str ] = Field ( max_items = 5 ) long_str_list : List [ str ] = Field ( min_items = 15 ) Use strict types to prevent to coercion from compatible types ( pydantic: Strict Types ) 1 2 3 4 5 6 7 8 9 from pydantic import StrictBool , StrictFloat , StrictStr from odmantic import Model class ExampleModel ( Model ): strict_bool : StrictBool strict_float : StrictFloat strict_str : StrictStr Define custom field validators ( pydantic: Validators ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from typing import ClassVar from pydantic import ValidationError , validator from odmantic import Model class SmallRectangle ( Model ): MAX_SIDE_SIZE : ClassVar [ float ] = 10 length : float width : float @validator ( \"width\" , \"length\" ) def check_small_sides ( cls , v ): if v > cls . MAX_SIDE_SIZE : raise ValueError ( f \"side is greater than { cls . MAX_SIDE_SIZE } \" ) return v @validator ( \"width\" ) def check_width_length ( cls , width , values , ** kwargs ): length = values . get ( \"length\" ) if length is not None and width > length : raise ValueError ( \"width can't be greater than length\" ) return width print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 40 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle length side is greater than 10 (type=value_error) \"\"\" Define custom model validators: more details Custom field types \u00b6 Exactly in the same way pydantic allows it, it's possible to define custom field types as well with ODMantic ( pydantic: Custom data types ). Sometimes, it might be required to customize as well the field BSON serialization. In order to do this, the field class will have to implement the __bson__ class method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from bson import Binary from odmantic import AIOEngine , Model class ASCIISerializedAsBinary ( str ): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , v ): if isinstance ( v , bytes ): # Handle data coming from MongoDB return v . decode ( \"ascii\" ) if not isinstance ( v , str ): raise TypeError ( \"string required\" ) if not v . isascii (): raise ValueError ( \"Only ascii characters are allowed\" ) return v @classmethod def __bson__ ( cls , v : str ): # We can encode this string as ascii since it contains # only ascii characters bytes_ = v . encode ( \"ascii\" ) return bytes_ class Example ( Model ): field : ASCIISerializedAsBinary engine = AIOEngine () await engine . save ( Example ( field = \"hello world\" )) fetched = await engine . find_one ( Example ) print ( fetched . field ) #> hello world In this example, we decide to store string data manually encoded in the ASCII encoding. The encoding is handled in the __bson__ class method. On top of this, we handle the decoding by attempting to decode bytes object in the validate method. Resulting documents in the collection example after execution { \"_id\" : Objec t Id( \"5f81fa5e8adaf4bf33f05035\" ) , \"field\" : Bi n Da ta ( 0 , \"aGVsbG8gd29ybGQ=\" ) } Warning When using custom bson serialization, it's important to handle as well the data validation for data retrieved from Mongo. In the previous example it's done by handling bytes objects in the validate method.","title":"Fields"},{"location":"fields/#fields","text":"","title":"Fields"},{"location":"fields/#the-id-field","text":"The ObjectId data type is the default primary key type used by MongoDB. An ObjectId comes with many information embedded into it (timestamp, machine identifier, ...). Since by default MongoDB will create a field _id containing an ObjectId primary key, ODMantic will bind it automatically to an implicit field named id . 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( leeroy . id ) #> ObjectId('5ed50fcad11d1975aa3d7a28') print ( repr ( leeroy )) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\") ObjectId creation This id field will be generated on instance creation, before saving the instance to the database. This helps to keep consistency between the instances persisted to the database and the ones only created locally. Even if this behavior is convenient, it is still possible to define custom primary keys .","title":"The id field"},{"location":"fields/#field-types","text":"","title":"Field types"},{"location":"fields/#optional-fields","text":"By default, every single field will be required. To specify a field as non-required, the easiest way is to use the typing.Optional generic type that will allow the field to take the None value as well (it will be stored as null in the database). 1 2 3 4 5 6 7 8 9 10 11 12 from typing import Optional from odmantic import Model class Person ( Model ): name : str age : Optional [ int ] john = Person ( name = \"John\" ) print ( john . age ) #> None","title":"Optional fields"},{"location":"fields/#union-fields","text":"As explained in the Python Typing documentation , Optional[X] is equivalent to Union[X, None] . That implies that the field type will be either X or None . It's possible to combine any kind of type using the typ\u00eeng.Union type constructor. For example if we want to allow both string and int in a field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from typing import Union from odmantic import Model class Thing ( Model ): ref_id : Union [ int , str ] thing_1 = Thing ( ref_id = 42 ) print ( thing_1 . ref_id ) #> 42 thing_2 = Thing ( ref_id = \"i am a string\" ) print ( thing_2 . ref_id ) #> i am a string NoneType Internally python describes the type of the None object as NoneType but in practice, None is used directly in type annotations ( more details ).","title":"Union fields"},{"location":"fields/#enum-fields","text":"To define choices, it's possible to use the standard enum classes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from enum import Enum from odmantic import AIOEngine , Model class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str kind : TreeKind sequoia = Tree ( name = \"Sequoia\" , kind = TreeKind . BIG ) print ( sequoia . kind ) #> TreeKind.BIG print ( sequoia . kind == \"big\" ) #> True spruce = Tree ( name = \"Spruce\" , kind = \"small\" ) print ( spruce . kind ) #> TreeKind.SMALL print ( spruce . kind == TreeKind . SMALL ) #> True engine = AIOEngine () await engine . save_all ([ sequoia , spruce ]) Resulting documents in the collection tree after execution { \"_id\" : Objec t Id( \"5f818f2dd5708527282c49b6\" ) , \"kind\" : \"big\" , \"name\" : \"Sequoia\" } { \"_id\" : Objec t Id( \"5f818f2dd5708527282c49b7\" ) , \"kind\" : \"small\" , \"name\" : \"Spruce\" } If you try to use a value not present in the allowed choices, a ValidationError exception will be raised. Usage of enum.auto If you might add some values to an Enum , it's strongly recommended not to use the enum.auto value generator. Depending on the order you add choices, it could completely break the consistency with documents stored in the database. Unwanted behavior example 1 2 3 4 5 6 7 8 9 10 11 12 from enum import Enum , auto class Color ( Enum ): RED = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . BLUE . value ) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from enum import Enum , auto class Color ( Enum ): RED = auto () GREEN = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . GREEN . value ) #> 2 print ( Color . BLUE . value ) #> 3","title":"Enum fields"},{"location":"fields/#container-fields","text":"","title":"Container fields"},{"location":"fields/#list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import List , Union from odmantic import Model class SimpleListModel ( Model ): field : list print ( SimpleListModel ( field = [ 1 , \"a\" , True ]) . field ) #> [1, 'a', True] print ( SimpleListModel ( field = ( 1 , \"a\" , True )) . field ) #> [1, 'a', True] class IntListModel ( Model ): field : List [ int ] print ( IntListModel ( field = [ 1 , 5 ]) . field ) #> [1, 5] print ( IntListModel ( field = ( 1 , 5 )) . field ) #> [1, 5] class IntStrListModel ( Model ): field : List [ Union [ int , str ]] print ( IntStrListModel ( field = [ 1 , \"b\" ]) . field ) #> [1, 'b'] print ( IntStrListModel ( field = ( 1 , \"b\" )) . field ) #> [1, 'b'] Tip It's possible to define element count constraints for a list field using the Field descriptor.","title":"List"},{"location":"fields/#tuple","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import Tuple from odmantic import Model class SimpleTupleModel ( Model ): field : tuple print ( SimpleTupleModel ( field = [ 1 , \"a\" , True ]) . field ) #> (1, 'a', True) print ( SimpleTupleModel ( field = ( 1 , \"a\" , True )) . field ) #> (1, 'a', True) class TwoIntTupleModel ( Model ): field : Tuple [ int , int ] print ( SimpleTupleModel ( field = ( 1 , 10 )) . field ) #> (1, 10) print ( SimpleTupleModel ( field = [ 1 , 10 ]) . field ) #> (1, 10) class IntTupleModel ( Model ): field : Tuple [ int , ... ] print ( IntTupleModel ( field = ( 1 ,)) . field ) #> (1,) print ( IntTupleModel ( field = [ 1 , 2 , 3 , 10 ]) . field ) #> (1, 2, 3, 10)","title":"Tuple"},{"location":"fields/#dict","text":"Tip For mapping types with already known keys, you can see the embedded models section . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from typing import Dict , Union from odmantic import Model class SimpleDictModel ( Model ): field : dict print ( SimpleDictModel ( field = { 18 : \"a string\" , True : 42 , 18.3 : [ 1 , 2 , 3 ]}) . field ) #> {18: 'a string', True: 42, 18.3: [1, 2, 3]} class IntStrDictModel ( Model ): field : Dict [ int , str ] print ( IntStrDictModel ( field = { 1 : \"one\" , 2 : \"two\" }) . field ) #> {1: 'one', 2: 'two'} class IntBoolStrDictModel ( Model ): field : Dict [ int , Union [ bool , str ]] print ( IntBoolStrDictModel ( field = { 0 : False , 1 : True , 3 : \"three\" }) . field ) #> {0: False, 1: True, 3: 'three'} Performance tip Whenever possible, try to avoid mutable container types ( List , Set , ...) and prefer their Immutable alternatives ( Tuple , FrozenSet , ...). This will allow ODMantic to speedup database writes by only saving the modified container fields.","title":"Dict"},{"location":"fields/#bson-types-integration","text":"ODMantic supports native python BSON types ( bson package ). Those types can be used directly as field types: bson.ObjectId bson.Int64 bson.Decimal128 bson.Regex bson.Binary Generic python to BSON type map Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal decimal str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array","title":"BSON types integration"},{"location":"fields/#pydantic-fields","text":"Most of the types supported by pydantic are supported by ODMantic. See pydantic: Field Types for more field types. Unsupported fields: typing.Callable Fields with a specific behavior: datetime.datetime : Only naive datetime objects will be allowed as MongoDB doesn't store the timezone information. Also, the microsecond information will be truncated.","title":"Pydantic fields"},{"location":"fields/#customization","text":"The field customization can mainly be performed using the Field descriptor. This descriptor is here to define everything about the field except its type.","title":"Customization"},{"location":"fields/#default-values","text":"The easiest way to set a default value to a field is by assigning this default value directly while defining the model. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cd4be16af832772f1615e'), name='Dash', level=0) You can combine default values and an existing Field descriptor using the default keyword argument. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Field , Model class Player ( Model ): name : str level : int = Field ( default = 1 , ge = 1 ) p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cdbfbb54a94e9e8717c77'), name='Dash', level=1) Default factory You may as well define a factory function instead of a value using the default_factory argument of the Field descriptor. By default, the default factories won't be used while parsing MongoDB documents. It's possible to enable this behavior with the parse_doc_with_default_factories Config option. Tip For typing.Optional fields, None is already set as the default value Default values validation Currently the default values are not validated yet during the model creation. An inconsistent default value might raise a ValidationError while building an instance.","title":"Default values"},{"location":"fields/#document-structure","text":"By default, the MongoDB documents fields will be named after the field name. It is possible to override this naming policy by using the key_name argument in the Field descriptor. 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( key_name = \"username\" ) engine = AIOEngine () await engine . save ( Player ( name = \"Jack\" )) Resulting documents in the collection player after execution { \"_id\" : Objec t Id( \"5ed50fcad11d1975aa3d7a28\" ) , \"username\" : \"Jack\" , } See this section for more details about the _id field that has been added.","title":"Document structure"},{"location":"fields/#primary-key","text":"While ODMantic will by default populate the id field as a primary key, you can use any other field as the primary key. 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( repr ( leeroy )) #> Player(name=\"Leeroy Jenkins\") engine = AIOEngine () await engine . save ( leeroy ) Resulting documents in the collection player after execution { \"_id\" : \"Leeroy Jenkins\" } Info The Mongo name of the primary field will be enforced to _id and you will not be able to change it. Warning Using mutable types (Set, List, ...) as primary field might result in inconsistent behaviors.","title":"Primary key"},{"location":"fields/#validation","text":"As ODMantic strongly relies on pydantic when it comes to data validation, most of the validation features provided by pydantic are available: Add field validation constraints by using the Field descriptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from typing import List from odmantic import Field , Model class ExampleModel ( Model ): small_int : int = Field ( le = 10 ) big_int : int = Field ( gt = 1000 ) even_int : int = Field ( multiple_of = 2 ) small_float : float = Field ( lt = 10 ) big_float : float = Field ( ge = 1e10 ) short_string : str = Field ( max_length = 10 ) long_string : str = Field ( min_length = 100 ) string_starting_with_the : str = Field ( regex = r \"^The\" ) short_str_list : List [ str ] = Field ( max_items = 5 ) long_str_list : List [ str ] = Field ( min_items = 15 ) Use strict types to prevent to coercion from compatible types ( pydantic: Strict Types ) 1 2 3 4 5 6 7 8 9 from pydantic import StrictBool , StrictFloat , StrictStr from odmantic import Model class ExampleModel ( Model ): strict_bool : StrictBool strict_float : StrictFloat strict_str : StrictStr Define custom field validators ( pydantic: Validators ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from typing import ClassVar from pydantic import ValidationError , validator from odmantic import Model class SmallRectangle ( Model ): MAX_SIDE_SIZE : ClassVar [ float ] = 10 length : float width : float @validator ( \"width\" , \"length\" ) def check_small_sides ( cls , v ): if v > cls . MAX_SIDE_SIZE : raise ValueError ( f \"side is greater than { cls . MAX_SIDE_SIZE } \" ) return v @validator ( \"width\" ) def check_width_length ( cls , width , values , ** kwargs ): length = values . get ( \"length\" ) if length is not None and width > length : raise ValueError ( \"width can't be greater than length\" ) return width print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 40 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle length side is greater than 10 (type=value_error) \"\"\" Define custom model validators: more details","title":"Validation"},{"location":"fields/#custom-field-types","text":"Exactly in the same way pydantic allows it, it's possible to define custom field types as well with ODMantic ( pydantic: Custom data types ). Sometimes, it might be required to customize as well the field BSON serialization. In order to do this, the field class will have to implement the __bson__ class method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from bson import Binary from odmantic import AIOEngine , Model class ASCIISerializedAsBinary ( str ): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , v ): if isinstance ( v , bytes ): # Handle data coming from MongoDB return v . decode ( \"ascii\" ) if not isinstance ( v , str ): raise TypeError ( \"string required\" ) if not v . isascii (): raise ValueError ( \"Only ascii characters are allowed\" ) return v @classmethod def __bson__ ( cls , v : str ): # We can encode this string as ascii since it contains # only ascii characters bytes_ = v . encode ( \"ascii\" ) return bytes_ class Example ( Model ): field : ASCIISerializedAsBinary engine = AIOEngine () await engine . save ( Example ( field = \"hello world\" )) fetched = await engine . find_one ( Example ) print ( fetched . field ) #> hello world In this example, we decide to store string data manually encoded in the ASCII encoding. The encoding is handled in the __bson__ class method. On top of this, we handle the decoding by attempting to decode bytes object in the validate method. Resulting documents in the collection example after execution { \"_id\" : Objec t Id( \"5f81fa5e8adaf4bf33f05035\" ) , \"field\" : Bi n Da ta ( 0 , \"aGVsbG8gd29ybGQ=\" ) } Warning When using custom bson serialization, it's important to handle as well the data validation for data retrieved from Mongo. In the previous example it's done by handling bytes objects in the validate method.","title":"Custom field types"},{"location":"modeling/","text":"Modeling \u00b6 Models \u00b6 To create a Model, simply inherit from the Model class and then specify the field types and eventually their descriptors. Collection \u00b6 Each Model will be linked to its own collection. By default, the collection name will be created from the chosen class name and converted to snake_case . For example a model class named CapitalCity will be stored in the collection named capital_city . If the class name ends with Model , ODMantic will remove it to create the collection name. For example, a model class named PersonModel will belong in the person collection. It's possible to customize the collection name of a model by specifying the collection option in the Config class. Custom collection name example from odmantic import Model class CapitalCity ( Model ): name : str population : int class Config : collection = \"city\" Now, when CapitalCity instances will be persisted to the database, they will belong in the city collection instead of capital_city . Warning Models and Embedded models inheritance is not supported yet. Custom model validators \u00b6 Exactly as done with pydantic, it's possible to define custom model validators as described in the pydantic: Root Validators documentation (this apply as well to Embedded Models). In the following example, we will define a rectangle class and add two validators: The first one will check that the height is greater than the width. The second one will ensure that the area of the rectangle is less or equal to 9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from typing import ClassVar from pydantic import ValidationError , root_validator from odmantic import Model class SmallRectangle ( Model ): MAX_AREA : ClassVar [ float ] = 9 length : float width : float @root_validator def check_width_length ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if width > length : raise ValueError ( \"width can't be greater than length\" ) return values @root_validator def check_area ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if length * width > cls . MAX_AREA : raise ValueError ( f \"area is greater than { cls . MAX_AREA } \" ) return values print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 4 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ area is greater than 9 (type=value_error) \"\"\" Tip You can define class variables in the Models using the typing.ClassVar type construct, as done in this example with MAX_AREA . Those class variables will be completely ignored by ODMantic while persisting instances to the database. Advanced Configuration \u00b6 The model configuration is done in the same way as with Pydantic models: using a Config class defined in the model body. Available options : collection : str Customize the collection name associated to the model. see this section for more details about default collection naming. parse_doc_with_default_factories : bool Wether to allow populating field values with default factories while parsing documents from the database. See this section for more details. Default: False title : str (inherited from Pydantic) Title inferred in the JSON schema. Default: name of the model class schema_extra : dict (inherited from Pydantic) A dict used to extend/update the generated JSON Schema, or a callable to post-process it. See Pydantic: Schema customization for more details. Default: {} anystr_strip_whitespace : bool (inherited from Pydantic) Whether to strip leading and trailing whitespaces for str & byte types. Default: False json_encoders : dict (inherited from Pydantic) Customize the way types used in the model are encoded to JSON. json_encoders example For example, in order to serialize datetime fields as timestamp values: class Event ( Model ): date : datetime class Config : json_encoders = { datetime : lambda v : v . timestamp () } json_loads (inherited from Pydantic) Function used to decode JSON data Default: json . loads json_dumps (inherited from Pydantic) Function used to encode JSON data Default: json . dumps extra : Extra (inherited from Pydantic) Whether to ignore, allow, or forbid extra attributes during model initialization Default: Extra . ignore For more details and examples about the options inherited from Pydantic, you can have a look to Pydantic: Model Config Warning Only the options described above are supported and other options from Pydantic can't be used with ODMantic. If you feel the need to have an additional option inherited from Pydantic, you can open an issue . Embedded Models \u00b6 Using an embedded model will store it directly in the root model it's integrated in. On the MongoDB side, the collection will contain the root documents and in inside each of them, the embedded models will be directly stored. Embedded models are especially useful while building one-to-one or one-to-many relationships. Note Since Embedded Models are directly embedded in the MongoDB collection of the root model, it will not be possible to query on them directly without specifying a root document. The creation of an Embedded model is done by inheriting the EmbeddedModel class. You can then define fields exactly as for the regular Models. One to One \u00b6 In this example, we will model the relation between a country and its capital city. Since one capital city can belong to one and only one country, we can model this relation as a One-to-One relationship. We will use an Embedded Model in this case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity countries = [ Country ( name = \"Switzerland\" , currency = \"Swiss franc\" , capital_city = CapitalCity ( name = \"Bern\" , population = 1035000 ), ), Country ( name = \"Sweden\" , currency = \"Swedish krona\" , capital_city = CapitalCity ( name = \"Stockholm\" , population = 975904 ), ), ] engine = AIOEngine () await engine . save_all ( countries ) Defining this relation is done in the same way as defining a new field. Here, the CapitalCity class will be considered as a field type during the model definition. The Field descriptor can be used as well for Embedded Models in order to bring more flexibility (default values, Mongo key name, ...). Content of the country collection after execution { \"_id\" : Objec t Id( \"5f79d7e8b305f24ca43593e2\" ) , \"name\" : \"Sweden\" , \"currency\" : \"Swedish krona\" , \"capital_city\" : { \"name\" : \"Stockholm\" , \"population\" : 975904 } } { \"_id\" : Objec t Id( \"5f79d7e8b305f24ca43593e1\" ) , \"name\" : \"Switzerland\" , \"currency\" : \"Swiss franc\" , \"capital_city\" : { \"name\" : \"Bern\" , \"population\" : 1035000 } } Tip It is possible as well to define query filters based on embedded documents content. await engine . find_one ( Country , Country . capital_city . name == \"Stockholm\" ) #> Country( #> id=ObjectId(\"5f79d7e8b305f24ca43593e2\"), #> name=\"Sweden\", #> currency=\"Swedish krona\", #> capital_city=CapitalCity(name=\"Stockholm\", population=975904), #> ) For more details, see the Querying section. One to Many \u00b6 Here, we will model the relation between a customer of an online shop and his shipping addresses. A single customer can have multiple addresses but these addresses belong only to the customer's account. He should be allowed to modify them without modifying others addresses (for example if two family members use the same address, their addresses should not be linked together). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from typing import List from odmantic import AIOEngine , EmbeddedModel , Model class Address ( EmbeddedModel ): street : str city : str state : str zipcode : str class Customer ( Model ): name : str addresses : List [ Address ] customer = Customer ( name = \"John Doe\" , addresses = [ Address ( street = \"1757 Birch Street\" , city = \"Greenwood\" , state = \"Indiana\" , zipcode = \"46142\" , ), Address ( street = \"262 Barnes Avenue\" , city = \"Cincinnati\" , state = \"Ohio\" , zipcode = \"45216\" , ), ], ) engine = AIOEngine () await engine . save ( customer ) As done previously for the One to One relation, defining a One to Many relationship with Embedded Models is done exactly as defining a field with its type being a sequence of Address objects. Content of the customer collection after execution { \"_id\" : Objec t Id( \"5f79eb116371e09b16e4fae4\" ) , \"name\" : \"John Doe\" , \"addresses\" :[ { \"street\" : \"1757 Birch Street\" , \"city\" : \"Greenwood\" , \"state\" : \"Indiana\" , \"zipcode\" : \"46142\" }, { \"street\" : \"262 Barnes Avenue\" , \"city\" : \"Cincinnati\" , \"state\" : \"Ohio\" , \"zipcode\" : \"45216\" } ] } Tip To add conditions on the number of embedded elements, it's possible to use the min_items and max_items arguments of the Field descriptor. Another possibility is to use the typing.Tuple type. Note Building query filters based on the content of a sequence of embedded documents is not supported yet (but this feature is planned for an upcoming release ). Anyway, it's still possible to perform the filtering operation manually using Mongo Array Operators ( $all , $elemMatch , $size ). See the Raw query usage section for more details. Customization \u00b6 Since the Embedded Models are considered as types by ODMantic, most of the complex type constructs that could be imagined should be supported. Some ideas which could be useful: Combine two different embedded models in a single field using typing.Tuple . Allow multiple Embedded model types using a typing.Union type. Make an Embedded model not required using typing.Optional . Embed the documents in a dictionary (using the typing.Dict type) to provide an additional key-value mapping to the embedded documents. Nest embedded documents Referenced models \u00b6 Embedded models are really simple to use but sometimes it is needed as well to have many-to-one (i.e. multiple entities referring to another single one) or many-to-many relationships. This is not really possible to model those using embedded documents and in this case, references will come handy. Another use case where references are useful is for one-to-one/one-to-many relations but when the referenced model has to exist in its own collection, in order to be accessed on its own without any parent model specified. Many to One (Mapped) \u00b6 In this part, we will model the relation between books and publishers. Let's consider that each book has a single publisher. In this case, multiple books could be published by the same publisher. We can thus model this relation as a many-to-one relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from odmantic import AIOEngine , Model , Reference class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference () hachette = Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ) harper = Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ) books = [ Book ( title = \"They Didn't See Us Coming\" , pages = 304 , publisher = hachette ), Book ( title = \"This Isn't Happening\" , pages = 256 , publisher = hachette ), Book ( title = \"Prodigal Summer\" , pages = 464 , publisher = harper ), ] engine = AIOEngine () await engine . save_all ( books ) The definition of a reference field requires the presence of the Reference() descriptor. Once the models are defined, linking two instances is done simply by assigning the reference field of referencing instance to the referenced instance. Why is it required to include the Reference descriptor ? The main goal behind enforcing the presence of the descriptor is to have a clear distinction between Embedded Models and References. In the future, a generic Reference[T] type will probably be included to make this distinction since it would make more sense than having to set a descriptor for each reference. Content of the publisher collection after execution { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a365\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } We can see that the publishers have been persisted to their collection even if no explicit save has been perfomed. When calling the engine.save method, the engine will persist automatically the referenced documents. While fetching instances, the engine will as well resolve every reference. Content of the book collection after execution { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a366\" ) , \"pages\" : 304 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"They Didn't See Us Coming\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a367\" ) , \"pages\" : 256 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"This Isn't Happening\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a368\" ) , \"pages\" : 464 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a365\" ) , \"title\" : \"Prodigal Summer\" } The resulting books in the collection contain the publisher reference directly as a document attribute (using the reference name as the document's key). Tip It's possible to customize the foreign key storage key using the key_name argument while building the Reference descriptor. Many to Many (Manual) \u00b6 Here, we will model the relation between books and their authors. Since a book can have multiple authors and an author can be authoring multiple books, we will model this relation as a many-to-many relationship. Note Currently, ODMantic does not support mapped multi-references yet. But we will still define the relationship in a manual way. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import List from bson import ObjectId from odmantic import AIOEngine , Model class Author ( Model ): name : str class Book ( Model ): title : str pages : int author_ids : List [ ObjectId ] david = Author ( name = \"David Beazley\" ) brian = Author ( name = \"Brian K. Jones\" ) python_cookbook = Book ( title = \"Python Cookbook\" , pages = 706 , author_ids = [ david . id , brian . id ] ) python_essentials = Book ( title = \"Python Essential Reference\" , pages = 717 , author_ids = [ brian . id ] ) engine = AIOEngine () await engine . save_all (( david , brian )) await engine . save_all (( python_cookbook , python_essentials )) We defined an author_ids field which holds the list of unique ids of the authors (This id field in the Author model is generated implicitly by default). Since this multi-reference is not mapped by the ODM, we have to persist the authors manually. Content of the author collection after execution { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da4e\" ) , \"name\" : \"David Beazley\" } { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) , \"name\" : \"Brian K. Jones\" } Content of the book collection after execution { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da50\" ) , \"title\" : \"Python Cookbook\" \"pages\" : 706 , \"author_ids\" :[ Objec t Id( \"5f7a37dc7311be1362e1da4e\" ) , Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) ], } { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da51\" ) , \"title\" : \"Python Essential Reference\" \"pages\" : 717 , \"author_ids\" :[ Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) ], } Retrieving the authors of the Python Cookbook First, it's required to fetch the ids of the authors. Then we can use the in_ filter to select only the authors with the desired ids. 1 2 3 4 5 6 7 book = await engine . find_one ( Book , Book . title == \"Python Cookbook\" ) authors = await engine . find ( Author , Author . id . in_ ( book . author_ids )) print ( authors ) #> [ #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4e\"), name=\"David Beazley\"), #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4f\"), name=\"Brian K. Jones\"), #> ]","title":"Modeling"},{"location":"modeling/#modeling","text":"","title":"Modeling"},{"location":"modeling/#models","text":"To create a Model, simply inherit from the Model class and then specify the field types and eventually their descriptors.","title":"Models"},{"location":"modeling/#collection","text":"Each Model will be linked to its own collection. By default, the collection name will be created from the chosen class name and converted to snake_case . For example a model class named CapitalCity will be stored in the collection named capital_city . If the class name ends with Model , ODMantic will remove it to create the collection name. For example, a model class named PersonModel will belong in the person collection. It's possible to customize the collection name of a model by specifying the collection option in the Config class. Custom collection name example from odmantic import Model class CapitalCity ( Model ): name : str population : int class Config : collection = \"city\" Now, when CapitalCity instances will be persisted to the database, they will belong in the city collection instead of capital_city . Warning Models and Embedded models inheritance is not supported yet.","title":"Collection"},{"location":"modeling/#custom-model-validators","text":"Exactly as done with pydantic, it's possible to define custom model validators as described in the pydantic: Root Validators documentation (this apply as well to Embedded Models). In the following example, we will define a rectangle class and add two validators: The first one will check that the height is greater than the width. The second one will ensure that the area of the rectangle is less or equal to 9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from typing import ClassVar from pydantic import ValidationError , root_validator from odmantic import Model class SmallRectangle ( Model ): MAX_AREA : ClassVar [ float ] = 9 length : float width : float @root_validator def check_width_length ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if width > length : raise ValueError ( \"width can't be greater than length\" ) return values @root_validator def check_area ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if length * width > cls . MAX_AREA : raise ValueError ( f \"area is greater than { cls . MAX_AREA } \" ) return values print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 4 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ area is greater than 9 (type=value_error) \"\"\" Tip You can define class variables in the Models using the typing.ClassVar type construct, as done in this example with MAX_AREA . Those class variables will be completely ignored by ODMantic while persisting instances to the database.","title":"Custom model validators"},{"location":"modeling/#advanced-configuration","text":"The model configuration is done in the same way as with Pydantic models: using a Config class defined in the model body. Available options : collection : str Customize the collection name associated to the model. see this section for more details about default collection naming. parse_doc_with_default_factories : bool Wether to allow populating field values with default factories while parsing documents from the database. See this section for more details. Default: False title : str (inherited from Pydantic) Title inferred in the JSON schema. Default: name of the model class schema_extra : dict (inherited from Pydantic) A dict used to extend/update the generated JSON Schema, or a callable to post-process it. See Pydantic: Schema customization for more details. Default: {} anystr_strip_whitespace : bool (inherited from Pydantic) Whether to strip leading and trailing whitespaces for str & byte types. Default: False json_encoders : dict (inherited from Pydantic) Customize the way types used in the model are encoded to JSON. json_encoders example For example, in order to serialize datetime fields as timestamp values: class Event ( Model ): date : datetime class Config : json_encoders = { datetime : lambda v : v . timestamp () } json_loads (inherited from Pydantic) Function used to decode JSON data Default: json . loads json_dumps (inherited from Pydantic) Function used to encode JSON data Default: json . dumps extra : Extra (inherited from Pydantic) Whether to ignore, allow, or forbid extra attributes during model initialization Default: Extra . ignore For more details and examples about the options inherited from Pydantic, you can have a look to Pydantic: Model Config Warning Only the options described above are supported and other options from Pydantic can't be used with ODMantic. If you feel the need to have an additional option inherited from Pydantic, you can open an issue .","title":"Advanced Configuration"},{"location":"modeling/#embedded-models","text":"Using an embedded model will store it directly in the root model it's integrated in. On the MongoDB side, the collection will contain the root documents and in inside each of them, the embedded models will be directly stored. Embedded models are especially useful while building one-to-one or one-to-many relationships. Note Since Embedded Models are directly embedded in the MongoDB collection of the root model, it will not be possible to query on them directly without specifying a root document. The creation of an Embedded model is done by inheriting the EmbeddedModel class. You can then define fields exactly as for the regular Models.","title":"Embedded Models"},{"location":"modeling/#one-to-one","text":"In this example, we will model the relation between a country and its capital city. Since one capital city can belong to one and only one country, we can model this relation as a One-to-One relationship. We will use an Embedded Model in this case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity countries = [ Country ( name = \"Switzerland\" , currency = \"Swiss franc\" , capital_city = CapitalCity ( name = \"Bern\" , population = 1035000 ), ), Country ( name = \"Sweden\" , currency = \"Swedish krona\" , capital_city = CapitalCity ( name = \"Stockholm\" , population = 975904 ), ), ] engine = AIOEngine () await engine . save_all ( countries ) Defining this relation is done in the same way as defining a new field. Here, the CapitalCity class will be considered as a field type during the model definition. The Field descriptor can be used as well for Embedded Models in order to bring more flexibility (default values, Mongo key name, ...). Content of the country collection after execution { \"_id\" : Objec t Id( \"5f79d7e8b305f24ca43593e2\" ) , \"name\" : \"Sweden\" , \"currency\" : \"Swedish krona\" , \"capital_city\" : { \"name\" : \"Stockholm\" , \"population\" : 975904 } } { \"_id\" : Objec t Id( \"5f79d7e8b305f24ca43593e1\" ) , \"name\" : \"Switzerland\" , \"currency\" : \"Swiss franc\" , \"capital_city\" : { \"name\" : \"Bern\" , \"population\" : 1035000 } } Tip It is possible as well to define query filters based on embedded documents content. await engine . find_one ( Country , Country . capital_city . name == \"Stockholm\" ) #> Country( #> id=ObjectId(\"5f79d7e8b305f24ca43593e2\"), #> name=\"Sweden\", #> currency=\"Swedish krona\", #> capital_city=CapitalCity(name=\"Stockholm\", population=975904), #> ) For more details, see the Querying section.","title":"One to One"},{"location":"modeling/#one-to-many","text":"Here, we will model the relation between a customer of an online shop and his shipping addresses. A single customer can have multiple addresses but these addresses belong only to the customer's account. He should be allowed to modify them without modifying others addresses (for example if two family members use the same address, their addresses should not be linked together). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from typing import List from odmantic import AIOEngine , EmbeddedModel , Model class Address ( EmbeddedModel ): street : str city : str state : str zipcode : str class Customer ( Model ): name : str addresses : List [ Address ] customer = Customer ( name = \"John Doe\" , addresses = [ Address ( street = \"1757 Birch Street\" , city = \"Greenwood\" , state = \"Indiana\" , zipcode = \"46142\" , ), Address ( street = \"262 Barnes Avenue\" , city = \"Cincinnati\" , state = \"Ohio\" , zipcode = \"45216\" , ), ], ) engine = AIOEngine () await engine . save ( customer ) As done previously for the One to One relation, defining a One to Many relationship with Embedded Models is done exactly as defining a field with its type being a sequence of Address objects. Content of the customer collection after execution { \"_id\" : Objec t Id( \"5f79eb116371e09b16e4fae4\" ) , \"name\" : \"John Doe\" , \"addresses\" :[ { \"street\" : \"1757 Birch Street\" , \"city\" : \"Greenwood\" , \"state\" : \"Indiana\" , \"zipcode\" : \"46142\" }, { \"street\" : \"262 Barnes Avenue\" , \"city\" : \"Cincinnati\" , \"state\" : \"Ohio\" , \"zipcode\" : \"45216\" } ] } Tip To add conditions on the number of embedded elements, it's possible to use the min_items and max_items arguments of the Field descriptor. Another possibility is to use the typing.Tuple type. Note Building query filters based on the content of a sequence of embedded documents is not supported yet (but this feature is planned for an upcoming release ). Anyway, it's still possible to perform the filtering operation manually using Mongo Array Operators ( $all , $elemMatch , $size ). See the Raw query usage section for more details.","title":"One to Many"},{"location":"modeling/#customization","text":"Since the Embedded Models are considered as types by ODMantic, most of the complex type constructs that could be imagined should be supported. Some ideas which could be useful: Combine two different embedded models in a single field using typing.Tuple . Allow multiple Embedded model types using a typing.Union type. Make an Embedded model not required using typing.Optional . Embed the documents in a dictionary (using the typing.Dict type) to provide an additional key-value mapping to the embedded documents. Nest embedded documents","title":"Customization"},{"location":"modeling/#referenced-models","text":"Embedded models are really simple to use but sometimes it is needed as well to have many-to-one (i.e. multiple entities referring to another single one) or many-to-many relationships. This is not really possible to model those using embedded documents and in this case, references will come handy. Another use case where references are useful is for one-to-one/one-to-many relations but when the referenced model has to exist in its own collection, in order to be accessed on its own without any parent model specified.","title":"Referenced models"},{"location":"modeling/#many-to-one-mapped","text":"In this part, we will model the relation between books and publishers. Let's consider that each book has a single publisher. In this case, multiple books could be published by the same publisher. We can thus model this relation as a many-to-one relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from odmantic import AIOEngine , Model , Reference class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference () hachette = Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ) harper = Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ) books = [ Book ( title = \"They Didn't See Us Coming\" , pages = 304 , publisher = hachette ), Book ( title = \"This Isn't Happening\" , pages = 256 , publisher = hachette ), Book ( title = \"Prodigal Summer\" , pages = 464 , publisher = harper ), ] engine = AIOEngine () await engine . save_all ( books ) The definition of a reference field requires the presence of the Reference() descriptor. Once the models are defined, linking two instances is done simply by assigning the reference field of referencing instance to the referenced instance. Why is it required to include the Reference descriptor ? The main goal behind enforcing the presence of the descriptor is to have a clear distinction between Embedded Models and References. In the future, a generic Reference[T] type will probably be included to make this distinction since it would make more sense than having to set a descriptor for each reference. Content of the publisher collection after execution { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a365\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } We can see that the publishers have been persisted to their collection even if no explicit save has been perfomed. When calling the engine.save method, the engine will persist automatically the referenced documents. While fetching instances, the engine will as well resolve every reference. Content of the book collection after execution { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a366\" ) , \"pages\" : 304 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"They Didn't See Us Coming\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a367\" ) , \"pages\" : 256 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"This Isn't Happening\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a368\" ) , \"pages\" : 464 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a365\" ) , \"title\" : \"Prodigal Summer\" } The resulting books in the collection contain the publisher reference directly as a document attribute (using the reference name as the document's key). Tip It's possible to customize the foreign key storage key using the key_name argument while building the Reference descriptor.","title":"Many to One (Mapped)"},{"location":"modeling/#many-to-many-manual","text":"Here, we will model the relation between books and their authors. Since a book can have multiple authors and an author can be authoring multiple books, we will model this relation as a many-to-many relationship. Note Currently, ODMantic does not support mapped multi-references yet. But we will still define the relationship in a manual way. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import List from bson import ObjectId from odmantic import AIOEngine , Model class Author ( Model ): name : str class Book ( Model ): title : str pages : int author_ids : List [ ObjectId ] david = Author ( name = \"David Beazley\" ) brian = Author ( name = \"Brian K. Jones\" ) python_cookbook = Book ( title = \"Python Cookbook\" , pages = 706 , author_ids = [ david . id , brian . id ] ) python_essentials = Book ( title = \"Python Essential Reference\" , pages = 717 , author_ids = [ brian . id ] ) engine = AIOEngine () await engine . save_all (( david , brian )) await engine . save_all (( python_cookbook , python_essentials )) We defined an author_ids field which holds the list of unique ids of the authors (This id field in the Author model is generated implicitly by default). Since this multi-reference is not mapped by the ODM, we have to persist the authors manually. Content of the author collection after execution { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da4e\" ) , \"name\" : \"David Beazley\" } { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) , \"name\" : \"Brian K. Jones\" } Content of the book collection after execution { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da50\" ) , \"title\" : \"Python Cookbook\" \"pages\" : 706 , \"author_ids\" :[ Objec t Id( \"5f7a37dc7311be1362e1da4e\" ) , Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) ], } { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da51\" ) , \"title\" : \"Python Essential Reference\" \"pages\" : 717 , \"author_ids\" :[ Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) ], } Retrieving the authors of the Python Cookbook First, it's required to fetch the ids of the authors. Then we can use the in_ filter to select only the authors with the desired ids. 1 2 3 4 5 6 7 book = await engine . find_one ( Book , Book . title == \"Python Cookbook\" ) authors = await engine . find ( Author , Author . id . in_ ( book . author_ids )) print ( authors ) #> [ #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4e\"), name=\"David Beazley\"), #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4f\"), name=\"Brian K. Jones\"), #> ]","title":"Many to Many (Manual)"},{"location":"querying/","text":"Querying \u00b6 Filtering \u00b6 ODMantic uses QueryExpression objects to handle filter expressions. These expressions can be built from the comparison operators. It's then possible to combine multiple expressions using the logical operators. To support the wide variety of operators provided by MongoDB, it's possible as well to define the filter 'manually'. Comparison operators \u00b6 There are multiple ways of building QueryExpression objects with comparisons operators: Using python comparison operators between the field of the model and the desired value == , != , <= , < , >= , > Using the functions provided by the odmantic.query module query.eq query.ne query.gt query.gte query.lt query.lte query.in_ query.not_in Using methods of the model's field and the desired value field.eq field.ne field.gte field.gt field.lte field.lte field.in_ field.not_in Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers. Equal \u00b6 Filter the trees named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name == \"Spruce\" #> QueryExpression({'name': {'$eq': 'Spruce'}}) Tree . name . eq ( \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) query . eq ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" } Using equality operators with Enum fields Building filters using Enum fields is possible as well. Example of filter built on an Enum field Filter the 'small' trees: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from enum import Enum from odmantic import Model , query class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str average_size : float kind : TreeKind Tree . kind == TreeKind . SMALL #> QueryExpression({'kind': {'$eq': 'small'}}) Tree . kind . eq ( TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) query . eq ( Tree . kind , TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) Equivalent raw MongoDB filter: { 'ki n d' : 'small' } More details about Enum fields. Not Equal \u00b6 Filter the trees that are not named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name != \"Spruce\" #> QueryExpression({'name': {'$ne': 'Spruce'}}) Tree . name . ne ( \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) query . ne ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : { \"$ne\" : \"Spruce\" }} Less than (or equal to) \u00b6 Filter the trees that have a size that is less than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size < 2 #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size . lt ( 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) query . lt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size <= 2 #> QueryExpression({'average_size': {'$lte': 2}}) Tree . average_size . lte ( 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) query . lte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) Equivalent raw MongoDB filter (less than): { \"average_size\" : { \"$lt\" : 2 }} Equivalent raw MongoDB filter (less than or equal to): { \"average_size\" : { \"$lte\" : 2 }} Greater than (or equal to) \u00b6 Filter the trees having a size that is greater than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size > 2 #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size . gt ( 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) query . gt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size >= 2 #> QueryExpression({'average_size': {'$gte': 2}}) Tree . average_size . gte ( 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) query . gte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) Equivalent raw MongoDB filter (greater than): { \"average_size\" : { \"$gt\" : 2 }} Equivalent raw MongoDB filter (greater than or equal to): { \"average_size\" : { \"$gte\" : 2 }} Included in \u00b6 Filter the trees named either \"Spruce\" or \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . in_ ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) query . in_ ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$in\" : [ \"Spruce\" , \"Pine\" ]}} Not included in \u00b6 Filter the trees neither named \"Spruce\" nor \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$nin\" : [ \"Spruce\" , \"Pine\" ]}} Evaluation operators \u00b6 Match (Regex) \u00b6 Filter the trees with a name starting with 'Spruce': 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model , query class Tree ( Model ): name : str Tree . name . match ( r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) query . match ( Tree . name , r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) Equivalent raw MongoDB filter: { \"name\" : { \"$regex\" : \"^Spruce\" }} Logical operators \u00b6 There are two ways of combining QueryExpression objects with logical operators: Using python 'bitwise' operators between the field of the model and the desired value & , | Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Using the functions provided by the odmantic.query module query.and_ query.or_ query.nor_ And \u00b6 Filter the trees named Spruce ( AND ) with a size less than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) & ( Tree . size <= 2 ) #> QueryExpression( #> { #> \"$and\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$lte\": 2}}), #> ) #> } #> ) query . and_ ( Tree . name == \"Spruce\" , Tree . size <= 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" , \"size\" : { \"$lte\" : 2 }}} Implicit AND When using find , find_one or count , you can specify multiple queries as positional arguments and those will be implicitly combined with the AND operator. Or \u00b6 Filter the trees named Spruce OR the trees with a size greater than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) | ( Tree . size > 2 ) #> QueryExpression( #> { #> \"$or\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$gt\": 2}}), #> ) #> } #> ) query . or_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"$or\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] } Nor \u00b6 Filter the trees neither named Spruce NOR bigger than 2 (size): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import Model , query class Tree ( Model ): name : str size : float query . nor_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) # > QueryExpression( # > { # > \"$nor\": ( # > QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), # > QueryExpression({\"size\": {\"$gt\": 2}}), # > ) # > } # > ) Equivalent raw MongoDB filter: { \"$nor\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] } NOR Equivalence The following logical expressions are equivalent: A NOR B NOR C NOT(A OR B OR C) NOT(A) AND NOT(B) AND NOT(C) query.nor_ operator naming query.and_ and query.or_ require to add an extra underscore to avoid overlapping with the python keywords. While it could've been possible to name the NOR operator query.nor, the extra underscore has been kept for consistency in the naming of the logical operators. Embedded documents filters \u00b6 It's possible to build filter based on the content of embedded documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity Country . capital_city . name == \"Paris\" #> QueryExpression({'capital_city.name': {'$eq': 'Paris'}}) Country . capital_city . population > 10 ** 6 #> QueryExpression({'capital_city.population': {'$gt': 1000000}}) Equivalent raw MongoDB filters: { \"capital_city.name\" : { \"$eq\" : \"Paris\" }} { \"capital_city.population\" : { \"$gt\" : 1000000 }} Filtering across References Currently, it is not possible to build filter based on referenced objects. Raw MongoDB filters \u00b6 Any QueryExpression can be replaced with raw MongoDB filters. Thus, it's completely possible to use traditional filters with the find , find_one or count methods. You can find more details about building raw query filters using the Model in the Raw query usage section. Sorting \u00b6 ODMantic uses SortExpression objects to handle sort expressions. There are multiple ways of building SortExpression objects: Using implicit Model fields: Ascending sort To sort Publisher instances by ascending Publisher.founded : await engine . find ( Publisher , sort = Publisher . founded ) This example refers to the code showcased in the Overview . Using the functions provided by the odmantic.query module query.asc query.desc Using methods of the model's field and the desired value field.asc field.desc Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers. Ascending \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by ascending `average_size` await engine . find ( Tree , sort = Tree . average_size ) await engine . find ( Tree , sort = Tree . average_size . asc ()) await engine . find ( Tree , sort = query . asc ( Tree . average_size )) Descending \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by descending `average_size` await engine . find ( Tree , sort = Tree . average_size . desc ()) await engine . find ( Tree , sort = query . desc ( Tree . average_size )) Sort on multiple fields \u00b6 We can pass a tuple to the sort kwarg, this will enable us to make a more complex sort query: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # This query will first sort on ascending `average_size`, then # on descending `name` when `average_size` is the same await engine . find ( Tree , sort = ( Tree . average_size , Tree . name . desc ())) Embedded model field as a sort key \u00b6 We can sort instances based on the content of their embedded models. Sorting by an embedded model field We can sort the countries by descending order of the population of their capital city: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import AIOEngine , EmbeddedModel , Model from odmantic.query import desc class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity engine = AIOEngine () await engine . find ( Country , sort = desc ( Country . capital_city . population ))","title":"Querying"},{"location":"querying/#querying","text":"","title":"Querying"},{"location":"querying/#filtering","text":"ODMantic uses QueryExpression objects to handle filter expressions. These expressions can be built from the comparison operators. It's then possible to combine multiple expressions using the logical operators. To support the wide variety of operators provided by MongoDB, it's possible as well to define the filter 'manually'.","title":"Filtering"},{"location":"querying/#comparison-operators","text":"There are multiple ways of building QueryExpression objects with comparisons operators: Using python comparison operators between the field of the model and the desired value == , != , <= , < , >= , > Using the functions provided by the odmantic.query module query.eq query.ne query.gt query.gte query.lt query.lte query.in_ query.not_in Using methods of the model's field and the desired value field.eq field.ne field.gte field.gt field.lte field.lte field.in_ field.not_in Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers.","title":"Comparison operators"},{"location":"querying/#equal","text":"Filter the trees named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name == \"Spruce\" #> QueryExpression({'name': {'$eq': 'Spruce'}}) Tree . name . eq ( \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) query . eq ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" } Using equality operators with Enum fields Building filters using Enum fields is possible as well. Example of filter built on an Enum field Filter the 'small' trees: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from enum import Enum from odmantic import Model , query class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str average_size : float kind : TreeKind Tree . kind == TreeKind . SMALL #> QueryExpression({'kind': {'$eq': 'small'}}) Tree . kind . eq ( TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) query . eq ( Tree . kind , TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) Equivalent raw MongoDB filter: { 'ki n d' : 'small' } More details about Enum fields.","title":"Equal"},{"location":"querying/#not-equal","text":"Filter the trees that are not named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name != \"Spruce\" #> QueryExpression({'name': {'$ne': 'Spruce'}}) Tree . name . ne ( \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) query . ne ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : { \"$ne\" : \"Spruce\" }}","title":"Not Equal"},{"location":"querying/#less-than-or-equal-to","text":"Filter the trees that have a size that is less than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size < 2 #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size . lt ( 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) query . lt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size <= 2 #> QueryExpression({'average_size': {'$lte': 2}}) Tree . average_size . lte ( 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) query . lte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) Equivalent raw MongoDB filter (less than): { \"average_size\" : { \"$lt\" : 2 }} Equivalent raw MongoDB filter (less than or equal to): { \"average_size\" : { \"$lte\" : 2 }}","title":"Less than (or equal to)"},{"location":"querying/#greater-than-or-equal-to","text":"Filter the trees having a size that is greater than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size > 2 #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size . gt ( 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) query . gt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size >= 2 #> QueryExpression({'average_size': {'$gte': 2}}) Tree . average_size . gte ( 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) query . gte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) Equivalent raw MongoDB filter (greater than): { \"average_size\" : { \"$gt\" : 2 }} Equivalent raw MongoDB filter (greater than or equal to): { \"average_size\" : { \"$gte\" : 2 }}","title":"Greater than (or equal to)"},{"location":"querying/#included-in","text":"Filter the trees named either \"Spruce\" or \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . in_ ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) query . in_ ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$in\" : [ \"Spruce\" , \"Pine\" ]}}","title":"Included in"},{"location":"querying/#not-included-in","text":"Filter the trees neither named \"Spruce\" nor \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$nin\" : [ \"Spruce\" , \"Pine\" ]}}","title":"Not included in"},{"location":"querying/#evaluation-operators","text":"","title":"Evaluation operators"},{"location":"querying/#match-regex","text":"Filter the trees with a name starting with 'Spruce': 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model , query class Tree ( Model ): name : str Tree . name . match ( r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) query . match ( Tree . name , r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) Equivalent raw MongoDB filter: { \"name\" : { \"$regex\" : \"^Spruce\" }}","title":"Match (Regex)"},{"location":"querying/#logical-operators","text":"There are two ways of combining QueryExpression objects with logical operators: Using python 'bitwise' operators between the field of the model and the desired value & , | Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Using the functions provided by the odmantic.query module query.and_ query.or_ query.nor_","title":"Logical operators"},{"location":"querying/#and","text":"Filter the trees named Spruce ( AND ) with a size less than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) & ( Tree . size <= 2 ) #> QueryExpression( #> { #> \"$and\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$lte\": 2}}), #> ) #> } #> ) query . and_ ( Tree . name == \"Spruce\" , Tree . size <= 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" , \"size\" : { \"$lte\" : 2 }}} Implicit AND When using find , find_one or count , you can specify multiple queries as positional arguments and those will be implicitly combined with the AND operator.","title":"And"},{"location":"querying/#or","text":"Filter the trees named Spruce OR the trees with a size greater than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) | ( Tree . size > 2 ) #> QueryExpression( #> { #> \"$or\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$gt\": 2}}), #> ) #> } #> ) query . or_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"$or\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] }","title":"Or"},{"location":"querying/#nor","text":"Filter the trees neither named Spruce NOR bigger than 2 (size): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import Model , query class Tree ( Model ): name : str size : float query . nor_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) # > QueryExpression( # > { # > \"$nor\": ( # > QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), # > QueryExpression({\"size\": {\"$gt\": 2}}), # > ) # > } # > ) Equivalent raw MongoDB filter: { \"$nor\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] } NOR Equivalence The following logical expressions are equivalent: A NOR B NOR C NOT(A OR B OR C) NOT(A) AND NOT(B) AND NOT(C) query.nor_ operator naming query.and_ and query.or_ require to add an extra underscore to avoid overlapping with the python keywords. While it could've been possible to name the NOR operator query.nor, the extra underscore has been kept for consistency in the naming of the logical operators.","title":"Nor"},{"location":"querying/#embedded-documents-filters","text":"It's possible to build filter based on the content of embedded documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity Country . capital_city . name == \"Paris\" #> QueryExpression({'capital_city.name': {'$eq': 'Paris'}}) Country . capital_city . population > 10 ** 6 #> QueryExpression({'capital_city.population': {'$gt': 1000000}}) Equivalent raw MongoDB filters: { \"capital_city.name\" : { \"$eq\" : \"Paris\" }} { \"capital_city.population\" : { \"$gt\" : 1000000 }} Filtering across References Currently, it is not possible to build filter based on referenced objects.","title":"Embedded documents filters"},{"location":"querying/#raw-mongodb-filters","text":"Any QueryExpression can be replaced with raw MongoDB filters. Thus, it's completely possible to use traditional filters with the find , find_one or count methods. You can find more details about building raw query filters using the Model in the Raw query usage section.","title":"Raw MongoDB filters"},{"location":"querying/#sorting","text":"ODMantic uses SortExpression objects to handle sort expressions. There are multiple ways of building SortExpression objects: Using implicit Model fields: Ascending sort To sort Publisher instances by ascending Publisher.founded : await engine . find ( Publisher , sort = Publisher . founded ) This example refers to the code showcased in the Overview . Using the functions provided by the odmantic.query module query.asc query.desc Using methods of the model's field and the desired value field.asc field.desc Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers.","title":"Sorting"},{"location":"querying/#ascending","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by ascending `average_size` await engine . find ( Tree , sort = Tree . average_size ) await engine . find ( Tree , sort = Tree . average_size . asc ()) await engine . find ( Tree , sort = query . asc ( Tree . average_size ))","title":"Ascending"},{"location":"querying/#descending","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by descending `average_size` await engine . find ( Tree , sort = Tree . average_size . desc ()) await engine . find ( Tree , sort = query . desc ( Tree . average_size ))","title":"Descending"},{"location":"querying/#sort-on-multiple-fields","text":"We can pass a tuple to the sort kwarg, this will enable us to make a more complex sort query: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # This query will first sort on ascending `average_size`, then # on descending `name` when `average_size` is the same await engine . find ( Tree , sort = ( Tree . average_size , Tree . name . desc ()))","title":"Sort on multiple fields"},{"location":"querying/#embedded-model-field-as-a-sort-key","text":"We can sort instances based on the content of their embedded models. Sorting by an embedded model field We can sort the countries by descending order of the population of their capital city: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import AIOEngine , EmbeddedModel , Model from odmantic.query import desc class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity engine = AIOEngine () await engine . find ( Country , sort = desc ( Country . capital_city . population ))","title":"Embedded model field as a sort key"},{"location":"raw_query_usage/","text":"Raw query usage \u00b6 As ODMantic doesn't completely wrap the MongoDB API, some helpers are provided to be enhance the usability while building raw queries and interacting with raw documents. Raw query helpers \u00b6 Collection name \u00b6 You can get the collection name associated to a model by using the unary + operator on the model class. 1 2 3 4 5 6 7 8 9 10 from odmantic import Model class User ( Model ): name : str collection_name = + User print ( collection_name ) #> user Motor collection \u00b6 The AIOEngine object can provide you directly the motor collection ( AsyncIOMotorCollection ) linked to the motor client used by the engine. To achieve this, you can use the AIOEngine.get_collection method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from odmantic import AIOEngine , Model class User ( Model ): name : str engine = AIOEngine () motor_collection = engine . get_collection ( User ) print ( motor_collection ) #> AsyncIOMotorCollection( #> Collection( #> Database( #> MongoClient( #> host=[\"localhost:27017\"], #> document_class=dict, #> tz_aware=False, #> connect=False, #> driver=DriverInfo(name=\"Motor\", version=\"2.2.0\", platform=\"asyncio\"), #> ), #> \"test\", #> ), #> \"user\", #> ) #> ) Key name of a field \u00b6 Since some field might have some customized key names , you can get the key name associated to a field by using the unary + operator on the model class. As well, to ease the use of aggregation pipelines where you might need to reference your field ( $field ), you can double the operator (i.e use ++ ) to get the field reference name. 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) print ( + User . name ) #> username print ( ++ User . name ) #> $username Using raw MongoDB filters \u00b6 Any QueryExpression can be replaced by its raw filter equivalent. For example, with a Tree model: 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Model class Tree ( Model ): name : str average_size : float engine = AIOEngine () All the following find queries would give exactly the same results: engine . find ( Tree , Tree . average_size > 2 ) engine . find ( Tree , { + Tree . average_size : { \"$gt\" : 2 }}) engine . find ( Tree , { \"average_size\" : { \"$gt\" : 2 }}) Raw MongoDB documents \u00b6 Parsing documents \u00b6 You can parse MongoDB document to instances using the parse_doc method. Tip If the provided documents contain extra fields, ODMantic will ignore them. This can be especially useful in aggregation pipelines. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from bson import ObjectId from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) document = { \"username\" : \"John\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( repr ( user )) #> User(id=ObjectId('5f8352a87a733b8b18b0cb27'), name='John') Dumping documents \u00b6 You can generate a document from instances using the doc method. 1 2 3 4 5 6 7 8 9 10 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) user = User ( name = \"John\" ) print ( user . doc ()) #> {'username': 'John', '_id': ObjectId('5f8352a87a733b8b18b0cb27')} Advanced parsing behavior \u00b6 Default values \u00b6 While parsing documents, ODMantic will use the default values provided in the Models to populate the missing fields from the documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from bson import ObjectId from odmantic import Model class Player ( Model ): name : str level : int = 1 document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = Player . parse_doc ( document ) print ( repr ( user )) #> Player( #> id=ObjectId(\"5f8352a87a733b8b18b0cb27\"), #> name=\"Leeroy\", #> level=1, #> ) Default factories \u00b6 For the field with default factories provided through the Field descriptor though, by default they wont be populated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from datetime import datetime from bson import ObjectId from odmantic import Model from odmantic.exceptions import DocumentParsingError from odmantic.field import Field class User ( Model ): name : str created_at : datetime = Field ( default_factory = datetime . utcnow ) document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} try : User . parse_doc ( document ) except DocumentParsingError as e : print ( e ) #> 1 validation error for User #> created_at #> key not found in document (type=value_error.keynotfoundindocument; key_name='created_at') #> (User instance details: id=ObjectId('5f8352a87a733b8b18b0cb27')) In the previous example, using the default factories could create data inconsistencies and in this case, it would probably be more suitable to perform a manual migration to provide the correct values. Still, the parse_doc_with_default_factories Config option can be used to allow the use of the default factories while parsing documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from datetime import datetime from bson import ObjectId from odmantic import Model from odmantic.exceptions import DocumentParsingError from odmantic.field import Field class User ( Model ): name : str updated_at : datetime = Field ( default_factory = datetime . utcnow ) class Config : parse_doc_with_default_factories = True document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( repr ( user )) #> User( #> id=ObjectId(\"5f8352a87a733b8b18b0cb27\"), #> name=\"Leeroy\", #> updated_at=datetime.datetime(2020, 11, 8, 23, 28, 19, 980000), #> ) Aggregation example \u00b6 In the following example, we will demonstrate the use of the previous helpers to build an aggregation pipeline. We will first consider a Rectangle model with two float fields ( height and length ). We will then fetch the rectangles with an area that is less than 10. To finish, we will reconstruct Rectangle instances from this query. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from odmantic import AIOEngine , Model class Rectangle ( Model ): length : float width : float rectangles = [ Rectangle ( length = 0.1 , width = 1 ), Rectangle ( length = 3.5 , width = 1 ), Rectangle ( length = 2.87 , width = 5.19 ), Rectangle ( length = 1 , width = 10 ), Rectangle ( length = 0.1 , width = 100 ), ] engine = AIOEngine () await engine . save_all ( rectangles ) collection = engine . get_collection ( Rectangle ) pipeline = [] # Add an area field pipeline . append ( { \"$addFields\" : { \"area\" : { \"$multiply\" : [ ++ Rectangle . length , ++ Rectangle . width ] } # Compute the area remotely } } ) # Filter only rectanges with an area lower than 10 pipeline . append ({ \"$match\" : { \"area\" : { \"$lt\" : 10 }}}) # Project to keep only the defined fields (this step is optional) pipeline . append ( { \"$project\" : { + Rectangle . length : True , + Rectangle . width : True , } # Specifying \"area\": False is unnecessary here } ) documents = await collection . aggregate ( pipeline ) . to_list ( length = None ) small_rectangles = [ Rectangle . parse_doc ( doc ) for doc in documents ] print ( small_rectangles ) #> [ #> Rectangle(id=ObjectId(\"...\"), length=0.1, width=1.0), #> Rectangle(id=ObjectId(\"...\"), length=3.5, width=1.0), #> ]","title":"Raw query usage"},{"location":"raw_query_usage/#raw-query-usage","text":"As ODMantic doesn't completely wrap the MongoDB API, some helpers are provided to be enhance the usability while building raw queries and interacting with raw documents.","title":"Raw query usage"},{"location":"raw_query_usage/#raw-query-helpers","text":"","title":"Raw query helpers"},{"location":"raw_query_usage/#collection-name","text":"You can get the collection name associated to a model by using the unary + operator on the model class. 1 2 3 4 5 6 7 8 9 10 from odmantic import Model class User ( Model ): name : str collection_name = + User print ( collection_name ) #> user","title":"Collection name"},{"location":"raw_query_usage/#motor-collection","text":"The AIOEngine object can provide you directly the motor collection ( AsyncIOMotorCollection ) linked to the motor client used by the engine. To achieve this, you can use the AIOEngine.get_collection method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from odmantic import AIOEngine , Model class User ( Model ): name : str engine = AIOEngine () motor_collection = engine . get_collection ( User ) print ( motor_collection ) #> AsyncIOMotorCollection( #> Collection( #> Database( #> MongoClient( #> host=[\"localhost:27017\"], #> document_class=dict, #> tz_aware=False, #> connect=False, #> driver=DriverInfo(name=\"Motor\", version=\"2.2.0\", platform=\"asyncio\"), #> ), #> \"test\", #> ), #> \"user\", #> ) #> )","title":"Motor collection"},{"location":"raw_query_usage/#key-name-of-a-field","text":"Since some field might have some customized key names , you can get the key name associated to a field by using the unary + operator on the model class. As well, to ease the use of aggregation pipelines where you might need to reference your field ( $field ), you can double the operator (i.e use ++ ) to get the field reference name. 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) print ( + User . name ) #> username print ( ++ User . name ) #> $username","title":"Key name of a field"},{"location":"raw_query_usage/#using-raw-mongodb-filters","text":"Any QueryExpression can be replaced by its raw filter equivalent. For example, with a Tree model: 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Model class Tree ( Model ): name : str average_size : float engine = AIOEngine () All the following find queries would give exactly the same results: engine . find ( Tree , Tree . average_size > 2 ) engine . find ( Tree , { + Tree . average_size : { \"$gt\" : 2 }}) engine . find ( Tree , { \"average_size\" : { \"$gt\" : 2 }})","title":"Using raw MongoDB filters"},{"location":"raw_query_usage/#raw-mongodb-documents","text":"","title":"Raw MongoDB documents"},{"location":"raw_query_usage/#parsing-documents","text":"You can parse MongoDB document to instances using the parse_doc method. Tip If the provided documents contain extra fields, ODMantic will ignore them. This can be especially useful in aggregation pipelines. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from bson import ObjectId from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) document = { \"username\" : \"John\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( repr ( user )) #> User(id=ObjectId('5f8352a87a733b8b18b0cb27'), name='John')","title":"Parsing documents"},{"location":"raw_query_usage/#dumping-documents","text":"You can generate a document from instances using the doc method. 1 2 3 4 5 6 7 8 9 10 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) user = User ( name = \"John\" ) print ( user . doc ()) #> {'username': 'John', '_id': ObjectId('5f8352a87a733b8b18b0cb27')}","title":"Dumping documents"},{"location":"raw_query_usage/#advanced-parsing-behavior","text":"","title":"Advanced parsing behavior"},{"location":"raw_query_usage/#default-values","text":"While parsing documents, ODMantic will use the default values provided in the Models to populate the missing fields from the documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from bson import ObjectId from odmantic import Model class Player ( Model ): name : str level : int = 1 document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = Player . parse_doc ( document ) print ( repr ( user )) #> Player( #> id=ObjectId(\"5f8352a87a733b8b18b0cb27\"), #> name=\"Leeroy\", #> level=1, #> )","title":"Default values"},{"location":"raw_query_usage/#default-factories","text":"For the field with default factories provided through the Field descriptor though, by default they wont be populated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from datetime import datetime from bson import ObjectId from odmantic import Model from odmantic.exceptions import DocumentParsingError from odmantic.field import Field class User ( Model ): name : str created_at : datetime = Field ( default_factory = datetime . utcnow ) document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} try : User . parse_doc ( document ) except DocumentParsingError as e : print ( e ) #> 1 validation error for User #> created_at #> key not found in document (type=value_error.keynotfoundindocument; key_name='created_at') #> (User instance details: id=ObjectId('5f8352a87a733b8b18b0cb27')) In the previous example, using the default factories could create data inconsistencies and in this case, it would probably be more suitable to perform a manual migration to provide the correct values. Still, the parse_doc_with_default_factories Config option can be used to allow the use of the default factories while parsing documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from datetime import datetime from bson import ObjectId from odmantic import Model from odmantic.exceptions import DocumentParsingError from odmantic.field import Field class User ( Model ): name : str updated_at : datetime = Field ( default_factory = datetime . utcnow ) class Config : parse_doc_with_default_factories = True document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( repr ( user )) #> User( #> id=ObjectId(\"5f8352a87a733b8b18b0cb27\"), #> name=\"Leeroy\", #> updated_at=datetime.datetime(2020, 11, 8, 23, 28, 19, 980000), #> )","title":"Default factories"},{"location":"raw_query_usage/#aggregation-example","text":"In the following example, we will demonstrate the use of the previous helpers to build an aggregation pipeline. We will first consider a Rectangle model with two float fields ( height and length ). We will then fetch the rectangles with an area that is less than 10. To finish, we will reconstruct Rectangle instances from this query. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from odmantic import AIOEngine , Model class Rectangle ( Model ): length : float width : float rectangles = [ Rectangle ( length = 0.1 , width = 1 ), Rectangle ( length = 3.5 , width = 1 ), Rectangle ( length = 2.87 , width = 5.19 ), Rectangle ( length = 1 , width = 10 ), Rectangle ( length = 0.1 , width = 100 ), ] engine = AIOEngine () await engine . save_all ( rectangles ) collection = engine . get_collection ( Rectangle ) pipeline = [] # Add an area field pipeline . append ( { \"$addFields\" : { \"area\" : { \"$multiply\" : [ ++ Rectangle . length , ++ Rectangle . width ] } # Compute the area remotely } } ) # Filter only rectanges with an area lower than 10 pipeline . append ({ \"$match\" : { \"area\" : { \"$lt\" : 10 }}}) # Project to keep only the defined fields (this step is optional) pipeline . append ( { \"$project\" : { + Rectangle . length : True , + Rectangle . width : True , } # Specifying \"area\": False is unnecessary here } ) documents = await collection . aggregate ( pipeline ) . to_list ( length = None ) small_rectangles = [ Rectangle . parse_doc ( doc ) for doc in documents ] print ( small_rectangles ) #> [ #> Rectangle(id=ObjectId(\"...\"), length=0.1, width=1.0), #> Rectangle(id=ObjectId(\"...\"), length=3.5, width=1.0), #> ]","title":"Aggregation example"},{"location":"usage_fastapi/","text":"Usage with FastAPI \u00b6 Example \u00b6 In this example, we create a minimalist REST API describing trees by their name, average size and discovery year. Requirements To run the following example, you'll need to install FastAPI and Uvicorn. pip install fastapi uvicorn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from typing import List from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree You can then start the application. For example if you saved the file above in a file named tree_api.py : uvicorn tree_api : app Uvicorn should start serving the API locally: INFO: Started server process [21429] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://localhost:8080 (Press CTRL+C to quit) To try it out, you can simply access the interactive documentation generated by FastAPI at http://localhost:8080/docs . We'll now dive in the details of this example. Defining the model \u00b6 First, we create our Tree model. class Tree ( Model ): name : str average_size : float discovery_year : int This describes our Tree instances structure both for JSON serialization and for the storage in the MongoDB collection. Building the engine \u00b6 After having defined the model, we create the AIOEngine object. This object will be responsible for performing database operations. engine = AIOEngine () It's possible as well to build the engine with custom parameters (mongo URI, database name). See this section for more details. Running the python file directly If you need to execute the python file directly with the interpreter (to use a debugger for example), some extra steps will be required. Run uvicorn using the default event loop (if the file is called directly): if __name__ == \"__main__\" : import asyncio import uvicorn loop = asyncio . get_event_loop () config = uvicorn . Config ( app = app , port = 8080 , loop = loop ) server = uvicorn . Server ( config ) loop . run_until_complete ( server . serve ()) uvicorn.run behavior with event loops (Advanced) The usual entrypoint uvicorn.run(app) for ASGI apps doesn't work because when called uvicorn will create and run a brand new event loop. Thus, the engine object will be bound to a different event loop that will not be running. In this case, you'll witness <Future pending> attached to a different loop errors because the app itself will be running in a different event loop than the engine's driver. Anyway, when running directly the app through the uvicorn CLI, the default event loop will be the one that will be running later, so no modifications are required. AIOEngineDependency deprecation (from v0.2.0) The AIOEngineDependency that was used to inject the engine in the API routes is now deprecated (it will be kept for few versions though). Using a global engine object should be preferred as it will dramatically reduce the required verbosity to use the engine in an endpoint. If you need to run your app directly from a python file, see the above Running the python file directly section. Creating a tree \u00b6 The next step is to define a route enabling us to create a new tree. To that end, we create a PUT route with the path /trees/ . This endpoint will receive a tree, persist it to the database and return the created object. @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree First, the request body will be parsed to a Tree object (this is done by specifying the argument tree: Tree ). This mean that the model validation will be performed. Once the model is parsed to a Tree instance, we persist it to the database and we return it. Command line tool for interacting with JSON based HTTP APIs To interact with the API from the command line, we recommend to use the HTTPie CLI. The next examples are still provided with the curl syntax since the Swagger documentation generated by FastAPI will give you curl examples directly. Creating a Tree from the command line HTTPie Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 2 Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 2.0, \"discovery_year\": 1995, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Spruce\" } curl Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":2}' Output: {\"name\":\"Spruce\",\"average_size\":2.0,\"discovery_year\":1995,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} You can notice that the id field has been added automatically by ODMantic. This id field is actually not required since it's defined automatically by ODMantic with a default factory method ( more details ). You can still specify this field in the request body to predefine the id of the created instance or to overwrite an existing instance. Why PUT instead of POST ? Since the engine.save behave as an upsert operation ( more details ), you can overwrite instances stored in the database by creating a new instance with the same id and calling the engine.save method. Modifying the Tree from the command line To overwrite the tree with id=5f8c8c1ff1d33aa1012f3086 : HTTPie Send the request: http PUT localhost:8080/trees/ \\ name = \"Norway Spruce\" discovery_year = 1795 \\ average_size = 200 id = \"5f8c8c1ff1d33aa1012f3086\" Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 200.0, \"discovery_year\": 1795, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Norway Spruce\" } curl Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Norway Spruce\", \"discovery_year\":1795, \"average_size\":200, \"id\":\"5f8c8c1ff1d33aa1012f3086\"}' Output: {\"name\":\"Norway Spruce\",\"average_size\":200.0,\"discovery_year\":1795,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} Since we can modify an existing instance, it makes more sense to define the operation as a PUT instead of a POST that should create a new resource on each call. If the request body doesn't match our model schema, a 422 Unprocessable Entity error will be returned by the API, containing the details about the error. Invalid data while creating the Tree from the command line You can try by omitting the average_size field: HTTPie Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 Output: HTTP/1.1 422 Unprocessable Entity content-length: 96 content-type: application/json date: Sun, 18 Oct 2020 16:42:18 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"body\", \"average_size\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" } ] } curl Send the request: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995}' Output: * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 8080 (#0) > PUT /trees/ HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.58.0 > Accept: */* > Content-Type: application/json > Content-Length: 40 > * upload completely sent off: 40 out of 40 bytes < HTTP/1.1 422 Unprocessable Entity < date: Sun, 18 Oct 2020 18:51:33 GMT < server: uvicorn < content-length: 96 < content-type: application/json < * Connection #0 to host localhost left intact {\"detail\":[{\"loc\":[\"body\",\"average_size\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}% The validation error structure is the one that is defined by the Pydantic: ValidationError exception. Finally, specifying the response_model in the app.put decorator is not mandatory but it is strongly advised as it helps FastAPI to generate the documentation. Getting all the trees \u00b6 To get the trees stored in the database, we use the AIOEngine.find method in its awaitable form ( more details ), this gives us directly the list of Tree instances that we can return directly: @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees Creating and getting the trees from the command line HTTPie Create some trees: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 10 .2 http PUT localhost:8080/trees/ name = \"Pine\" discovery_year = 1850 average_size = 5 Get the trees: http localhost:8080/trees/ Output: HTTP/1.1 200 OK content-length: 270 content-type: application/json date: Sun, 18 Oct 2020 17:59:10 GMT server: uvicorn [ { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" }, { \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Pine\" } ] curl Create some trees: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":10.2}' curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Pine\", \"discovery_year\":1850, \"average_size\":5}' Get the trees: curl http://localhost:8080/trees/ | python -mjson.tool Output: [ { \"name\": \"Spruce\", \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\" }, { \"name\": \"Pine\", \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\" } ] Pagination You can add pagination to this GET request by using the skip and limit arguments while calling the AIOEngine.find method. Counting the trees \u00b6 To get the number of trees stored in the database, we use the AIOEngine.count method without specifying any query parameters (to directly get the total count of instances). @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count Getting the tree count from the command line HTTPie Get the count: http localhost:8080/trees/count Output: HTTP/1.1 200 OK content-length: 1 content-type: application/json date: Sun, 18 Oct 2020 20:16:50 GMT server: uvicorn 2 curl Get the count: curl http://localhost:8080/trees/count Output: 2 Getting a tree by id \u00b6 @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId , ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree To return a tree from its id we add a path parameter id: ObjectId . Once this endpoint is called, FastAPI will try to validate this query parameter, thus inferring an ObjectId object. Using BSON objects as parameters While you can define ODMantic models directly using bson fields ( more details ), it's not possible to use those types directly with FastAPI, you'll need to get the equivalent objects from the odmantic.bson module. Those equivalent types implement the additional validation logic enabling FastAPI to work with them. from odmantic.bson import ObjectId For convenience reasons, the ObjectId type including the validation logic is as well available directly from the odmantic module. from odmantic import ObjectId With this ObjectId , we build a query that will filter only the instances having this exactly same id : Tree . id == id Then, we pass this query to the AIOEngine.find_one method that will try to return an instance, otherwise None will be returned: tree = await engine . find_one ( Tree , Tree . id == id ) Now, if our tree object is None (i.e the instance has not been found), we need to return a 404 Not Found error: if tree is None : raise HTTPException ( 404 ) Otherwise, we found the requested instance. We can return it ! return tree Getting a tree from the command line HTTPie Get the tree 5f8c8266f1d33aa1012f3082 : http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:08:07 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } curl Get the tree 5f8c8266f1d33aa1012f3082 : curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Trying to get a tree not in the database from the command line HTTPie Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): http localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:11:48 GMT server: uvicorn { \"detail\": \"Not Found\" } curl Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): curl http://localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: {\"detail\":\"Not Found\"} This id path parameter should be a 16 characters hexadecimal string (see MongoDB: ObjectId for more details). If the id specified in the path does not match this criteria, a 422 Unprocessable Entity error will be returned: Trying to get a tree with an invalid id from the command line HTTPie Get the tree identified by invalid_object_id : http localhost:8080/trees/invalid_object_id Output: HTTP/1.1 422 Unprocessable Entity content-length: 89 content-type: application/json date: Sun, 18 Oct 2020 20:50:25 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"path\", \"id\" ], \"msg\": \"invalid ObjectId specified\", \"type\": \"type_error\" } ] } curl Get the tree identified by invalid_object_id : curl http://localhost:8080/trees/invalid_object_id Output: {\"detail\":[{\"loc\":[\"path\",\"id\"],\"msg\":\"invalid ObjectId specified\",\"type\":\"type_error\"}]} Extending the example \u00b6 Deleting a tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import uvicorn from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree @app . delete ( \"/trees/ {id} \" , response_model = Tree ) async def delete_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) await engine . delete ( tree ) return tree This new DELETE route is strongly inspired from the one used to get a tree from its id . Currently, ODMantic can only delete an instance and it's not possible to perform a delete operation from a query filter. Thus, we first need to get the associated instance. Once we have the instance, we call the AIOEngine.delete method to perform the deletion. Deleting a tree from the command line HTTPie Delete the tree identified by 5f8c8266f1d33aa1012f3082 : http DELETE localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:35:22 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } Check that the tree is not stored anymore: http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:36:45 GMT server: uvicorn { \"detail\": \"Not Found\" } curl Delete the tree identified by 5f8c8266f1d33aa1012f3082 : curl -X DELETE http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Check that the tree is not stored anymore: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"detail\":\"Not Found\"} The tree has been removed successfully ! Updating a tree \u00b6 We already defined a PUT route that enables us to modify (replace) a tree instance. However, with this previous implementation, it's not possible to specify only the fields that we want to change as the whole Tree instance is rebuilt from the request's body. In this example, we will define a PATCH method that will allow us to modify only some specific fields of a Tree instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from fastapi import FastAPI , HTTPException from pydantic import BaseModel from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree class TreePatchSchema ( BaseModel ): name : str = None average_size : float = None discovery_year : float = None @app . patch ( \"/trees/ {id} \" , response_model = Tree ) async def update_tree_by_id ( id : ObjectId , patch : TreePatchSchema ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) tree . update ( patch ) await engine . save ( tree ) return tree First, we define the TreePatchSchema this Pydantic model will contain the modifications that we need to apply on the instance. Since we want to be able to update each field independently, we give each of them the None default value. Then, we configure a new PATCH endpoint by setting the id of the model to update as a path parameter and the TreePatchSchema as the request body parameter. After all the parameters have been validated properly and the appropriate instance have been gathered, we can apply the modifications to the local instance using the Model.update method. By default, the update method will replace each field values in the instance with the ones explicitely set in the patch object. Thus, the fields containing the None default values are not gonna be changed in the instance. We can then finish by saving and returning the updated tree. Optional, defaults, non-required and required pydantic fields (advanced) from pydantic import BaseModel class M ( BaseModel ): a : Optional [ int ] b : Optional [ int ] = None c : int = None d : int In this example, fields have a different behavior: a : Optional [ int ] this field is not required , None is its default value, it can be given None or any int values b : Optional [ int ] = None same behavior as a since None is set automatically as the default value for typing.Optional fields c : int = None this field is not required , if not explicitely provided it will take the None value, only an int can be given as an explicit value d : int this field is required and an int value must be provided (More details: pydantic #1223 , pydantic: Required fields ) By default Model.update , will not apply values from unset (not explicitely populated) fields. Since we don't want to allow explicitely set None values in the example, we used fields defined as c : int = None . Updating a tree from the command line HTTPie Update the tree identified by 5f8c8266f1d33aa1012f3083 : http PATCH localhost:8080/trees/5f8c8266f1d33aa1012f3083 \\ discovery_year = 1825 name = \"Stone Pine\" Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:02:44 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } Check that the tree has been updated properly: http localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:06:52 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } curl Update the tree identified by 5f8c8266f1d33aa1012f3083 : curl -X PATCH \"http://localhost:8080/trees/5f8c8266f1d33aa1012f3083\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Stone Pine\", \"discovery_year\":1825}' Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} Check that the tree has been updated properly: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} The tree has been updated successfully ! Upcoming features \u00b6 A lot of feature could still improve the ODMantic + FastAPI experience. Some ideas that should arrive soon: Add a not_found_exception argument to the AIOEngine.find_one method. Thus, if the document is not found an exception will be raised directly. Implement the equivalent of MongoDB insert method to be able to create document without overwriting existing ones. Implement a Model.update method to update the model fields from a dictionnary or from a Pydantic schema. Automatically generate CRUD endpoints directly from an ODMantic Model.","title":"Usage with FastAPI"},{"location":"usage_fastapi/#usage-with-fastapi","text":"","title":"Usage with FastAPI"},{"location":"usage_fastapi/#example","text":"In this example, we create a minimalist REST API describing trees by their name, average size and discovery year. Requirements To run the following example, you'll need to install FastAPI and Uvicorn. pip install fastapi uvicorn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from typing import List from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree You can then start the application. For example if you saved the file above in a file named tree_api.py : uvicorn tree_api : app Uvicorn should start serving the API locally: INFO: Started server process [21429] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://localhost:8080 (Press CTRL+C to quit) To try it out, you can simply access the interactive documentation generated by FastAPI at http://localhost:8080/docs . We'll now dive in the details of this example.","title":"Example"},{"location":"usage_fastapi/#defining-the-model","text":"First, we create our Tree model. class Tree ( Model ): name : str average_size : float discovery_year : int This describes our Tree instances structure both for JSON serialization and for the storage in the MongoDB collection.","title":"Defining the model"},{"location":"usage_fastapi/#building-the-engine","text":"After having defined the model, we create the AIOEngine object. This object will be responsible for performing database operations. engine = AIOEngine () It's possible as well to build the engine with custom parameters (mongo URI, database name). See this section for more details. Running the python file directly If you need to execute the python file directly with the interpreter (to use a debugger for example), some extra steps will be required. Run uvicorn using the default event loop (if the file is called directly): if __name__ == \"__main__\" : import asyncio import uvicorn loop = asyncio . get_event_loop () config = uvicorn . Config ( app = app , port = 8080 , loop = loop ) server = uvicorn . Server ( config ) loop . run_until_complete ( server . serve ()) uvicorn.run behavior with event loops (Advanced) The usual entrypoint uvicorn.run(app) for ASGI apps doesn't work because when called uvicorn will create and run a brand new event loop. Thus, the engine object will be bound to a different event loop that will not be running. In this case, you'll witness <Future pending> attached to a different loop errors because the app itself will be running in a different event loop than the engine's driver. Anyway, when running directly the app through the uvicorn CLI, the default event loop will be the one that will be running later, so no modifications are required. AIOEngineDependency deprecation (from v0.2.0) The AIOEngineDependency that was used to inject the engine in the API routes is now deprecated (it will be kept for few versions though). Using a global engine object should be preferred as it will dramatically reduce the required verbosity to use the engine in an endpoint. If you need to run your app directly from a python file, see the above Running the python file directly section.","title":"Building the engine"},{"location":"usage_fastapi/#creating-a-tree","text":"The next step is to define a route enabling us to create a new tree. To that end, we create a PUT route with the path /trees/ . This endpoint will receive a tree, persist it to the database and return the created object. @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree First, the request body will be parsed to a Tree object (this is done by specifying the argument tree: Tree ). This mean that the model validation will be performed. Once the model is parsed to a Tree instance, we persist it to the database and we return it. Command line tool for interacting with JSON based HTTP APIs To interact with the API from the command line, we recommend to use the HTTPie CLI. The next examples are still provided with the curl syntax since the Swagger documentation generated by FastAPI will give you curl examples directly. Creating a Tree from the command line HTTPie Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 2 Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 2.0, \"discovery_year\": 1995, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Spruce\" } curl Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":2}' Output: {\"name\":\"Spruce\",\"average_size\":2.0,\"discovery_year\":1995,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} You can notice that the id field has been added automatically by ODMantic. This id field is actually not required since it's defined automatically by ODMantic with a default factory method ( more details ). You can still specify this field in the request body to predefine the id of the created instance or to overwrite an existing instance. Why PUT instead of POST ? Since the engine.save behave as an upsert operation ( more details ), you can overwrite instances stored in the database by creating a new instance with the same id and calling the engine.save method. Modifying the Tree from the command line To overwrite the tree with id=5f8c8c1ff1d33aa1012f3086 : HTTPie Send the request: http PUT localhost:8080/trees/ \\ name = \"Norway Spruce\" discovery_year = 1795 \\ average_size = 200 id = \"5f8c8c1ff1d33aa1012f3086\" Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 200.0, \"discovery_year\": 1795, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Norway Spruce\" } curl Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Norway Spruce\", \"discovery_year\":1795, \"average_size\":200, \"id\":\"5f8c8c1ff1d33aa1012f3086\"}' Output: {\"name\":\"Norway Spruce\",\"average_size\":200.0,\"discovery_year\":1795,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} Since we can modify an existing instance, it makes more sense to define the operation as a PUT instead of a POST that should create a new resource on each call. If the request body doesn't match our model schema, a 422 Unprocessable Entity error will be returned by the API, containing the details about the error. Invalid data while creating the Tree from the command line You can try by omitting the average_size field: HTTPie Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 Output: HTTP/1.1 422 Unprocessable Entity content-length: 96 content-type: application/json date: Sun, 18 Oct 2020 16:42:18 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"body\", \"average_size\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" } ] } curl Send the request: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995}' Output: * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 8080 (#0) > PUT /trees/ HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.58.0 > Accept: */* > Content-Type: application/json > Content-Length: 40 > * upload completely sent off: 40 out of 40 bytes < HTTP/1.1 422 Unprocessable Entity < date: Sun, 18 Oct 2020 18:51:33 GMT < server: uvicorn < content-length: 96 < content-type: application/json < * Connection #0 to host localhost left intact {\"detail\":[{\"loc\":[\"body\",\"average_size\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}% The validation error structure is the one that is defined by the Pydantic: ValidationError exception. Finally, specifying the response_model in the app.put decorator is not mandatory but it is strongly advised as it helps FastAPI to generate the documentation.","title":"Creating a tree"},{"location":"usage_fastapi/#getting-all-the-trees","text":"To get the trees stored in the database, we use the AIOEngine.find method in its awaitable form ( more details ), this gives us directly the list of Tree instances that we can return directly: @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees Creating and getting the trees from the command line HTTPie Create some trees: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 10 .2 http PUT localhost:8080/trees/ name = \"Pine\" discovery_year = 1850 average_size = 5 Get the trees: http localhost:8080/trees/ Output: HTTP/1.1 200 OK content-length: 270 content-type: application/json date: Sun, 18 Oct 2020 17:59:10 GMT server: uvicorn [ { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" }, { \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Pine\" } ] curl Create some trees: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":10.2}' curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Pine\", \"discovery_year\":1850, \"average_size\":5}' Get the trees: curl http://localhost:8080/trees/ | python -mjson.tool Output: [ { \"name\": \"Spruce\", \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\" }, { \"name\": \"Pine\", \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\" } ] Pagination You can add pagination to this GET request by using the skip and limit arguments while calling the AIOEngine.find method.","title":"Getting all the trees"},{"location":"usage_fastapi/#counting-the-trees","text":"To get the number of trees stored in the database, we use the AIOEngine.count method without specifying any query parameters (to directly get the total count of instances). @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count Getting the tree count from the command line HTTPie Get the count: http localhost:8080/trees/count Output: HTTP/1.1 200 OK content-length: 1 content-type: application/json date: Sun, 18 Oct 2020 20:16:50 GMT server: uvicorn 2 curl Get the count: curl http://localhost:8080/trees/count Output: 2","title":"Counting the trees"},{"location":"usage_fastapi/#getting-a-tree-by-id","text":"@app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId , ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree To return a tree from its id we add a path parameter id: ObjectId . Once this endpoint is called, FastAPI will try to validate this query parameter, thus inferring an ObjectId object. Using BSON objects as parameters While you can define ODMantic models directly using bson fields ( more details ), it's not possible to use those types directly with FastAPI, you'll need to get the equivalent objects from the odmantic.bson module. Those equivalent types implement the additional validation logic enabling FastAPI to work with them. from odmantic.bson import ObjectId For convenience reasons, the ObjectId type including the validation logic is as well available directly from the odmantic module. from odmantic import ObjectId With this ObjectId , we build a query that will filter only the instances having this exactly same id : Tree . id == id Then, we pass this query to the AIOEngine.find_one method that will try to return an instance, otherwise None will be returned: tree = await engine . find_one ( Tree , Tree . id == id ) Now, if our tree object is None (i.e the instance has not been found), we need to return a 404 Not Found error: if tree is None : raise HTTPException ( 404 ) Otherwise, we found the requested instance. We can return it ! return tree Getting a tree from the command line HTTPie Get the tree 5f8c8266f1d33aa1012f3082 : http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:08:07 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } curl Get the tree 5f8c8266f1d33aa1012f3082 : curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Trying to get a tree not in the database from the command line HTTPie Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): http localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:11:48 GMT server: uvicorn { \"detail\": \"Not Found\" } curl Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): curl http://localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: {\"detail\":\"Not Found\"} This id path parameter should be a 16 characters hexadecimal string (see MongoDB: ObjectId for more details). If the id specified in the path does not match this criteria, a 422 Unprocessable Entity error will be returned: Trying to get a tree with an invalid id from the command line HTTPie Get the tree identified by invalid_object_id : http localhost:8080/trees/invalid_object_id Output: HTTP/1.1 422 Unprocessable Entity content-length: 89 content-type: application/json date: Sun, 18 Oct 2020 20:50:25 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"path\", \"id\" ], \"msg\": \"invalid ObjectId specified\", \"type\": \"type_error\" } ] } curl Get the tree identified by invalid_object_id : curl http://localhost:8080/trees/invalid_object_id Output: {\"detail\":[{\"loc\":[\"path\",\"id\"],\"msg\":\"invalid ObjectId specified\",\"type\":\"type_error\"}]}","title":"Getting a tree by id"},{"location":"usage_fastapi/#extending-the-example","text":"","title":"Extending the example"},{"location":"usage_fastapi/#deleting-a-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import uvicorn from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree @app . delete ( \"/trees/ {id} \" , response_model = Tree ) async def delete_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) await engine . delete ( tree ) return tree This new DELETE route is strongly inspired from the one used to get a tree from its id . Currently, ODMantic can only delete an instance and it's not possible to perform a delete operation from a query filter. Thus, we first need to get the associated instance. Once we have the instance, we call the AIOEngine.delete method to perform the deletion. Deleting a tree from the command line HTTPie Delete the tree identified by 5f8c8266f1d33aa1012f3082 : http DELETE localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:35:22 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } Check that the tree is not stored anymore: http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:36:45 GMT server: uvicorn { \"detail\": \"Not Found\" } curl Delete the tree identified by 5f8c8266f1d33aa1012f3082 : curl -X DELETE http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Check that the tree is not stored anymore: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"detail\":\"Not Found\"} The tree has been removed successfully !","title":"Deleting a tree"},{"location":"usage_fastapi/#updating-a-tree","text":"We already defined a PUT route that enables us to modify (replace) a tree instance. However, with this previous implementation, it's not possible to specify only the fields that we want to change as the whole Tree instance is rebuilt from the request's body. In this example, we will define a PATCH method that will allow us to modify only some specific fields of a Tree instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from fastapi import FastAPI , HTTPException from pydantic import BaseModel from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree class TreePatchSchema ( BaseModel ): name : str = None average_size : float = None discovery_year : float = None @app . patch ( \"/trees/ {id} \" , response_model = Tree ) async def update_tree_by_id ( id : ObjectId , patch : TreePatchSchema ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) tree . update ( patch ) await engine . save ( tree ) return tree First, we define the TreePatchSchema this Pydantic model will contain the modifications that we need to apply on the instance. Since we want to be able to update each field independently, we give each of them the None default value. Then, we configure a new PATCH endpoint by setting the id of the model to update as a path parameter and the TreePatchSchema as the request body parameter. After all the parameters have been validated properly and the appropriate instance have been gathered, we can apply the modifications to the local instance using the Model.update method. By default, the update method will replace each field values in the instance with the ones explicitely set in the patch object. Thus, the fields containing the None default values are not gonna be changed in the instance. We can then finish by saving and returning the updated tree. Optional, defaults, non-required and required pydantic fields (advanced) from pydantic import BaseModel class M ( BaseModel ): a : Optional [ int ] b : Optional [ int ] = None c : int = None d : int In this example, fields have a different behavior: a : Optional [ int ] this field is not required , None is its default value, it can be given None or any int values b : Optional [ int ] = None same behavior as a since None is set automatically as the default value for typing.Optional fields c : int = None this field is not required , if not explicitely provided it will take the None value, only an int can be given as an explicit value d : int this field is required and an int value must be provided (More details: pydantic #1223 , pydantic: Required fields ) By default Model.update , will not apply values from unset (not explicitely populated) fields. Since we don't want to allow explicitely set None values in the example, we used fields defined as c : int = None . Updating a tree from the command line HTTPie Update the tree identified by 5f8c8266f1d33aa1012f3083 : http PATCH localhost:8080/trees/5f8c8266f1d33aa1012f3083 \\ discovery_year = 1825 name = \"Stone Pine\" Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:02:44 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } Check that the tree has been updated properly: http localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:06:52 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } curl Update the tree identified by 5f8c8266f1d33aa1012f3083 : curl -X PATCH \"http://localhost:8080/trees/5f8c8266f1d33aa1012f3083\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Stone Pine\", \"discovery_year\":1825}' Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} Check that the tree has been updated properly: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} The tree has been updated successfully !","title":"Updating a tree"},{"location":"usage_fastapi/#upcoming-features","text":"A lot of feature could still improve the ODMantic + FastAPI experience. Some ideas that should arrive soon: Add a not_found_exception argument to the AIOEngine.find_one method. Thus, if the document is not found an exception will be raised directly. Implement the equivalent of MongoDB insert method to be able to create document without overwriting existing ones. Implement a Model.update method to update the model fields from a dictionnary or from a Pydantic schema. Automatically generate CRUD endpoints directly from an ODMantic Model.","title":"Upcoming features"},{"location":"usage_pydantic/","text":"Usage with Pydantic \u00b6 Defining models with BSON Fields \u00b6 You might need to define pure Pydantic models which include BSON fields. To that end, you can use the BaseBSONModel as the base class of your Pydantic models. This class adds the JSON encoders required to handle the BSON fields. Also, you will have to use the bson equivalent types defined in the odmantic.bson module. Those types, add a validation logic to the native types from the bson module. Custom json_encoders with BaseBSONModel If you want to specify additional json encoders, with a Pydantic model containing BSON fields, you will need to pass as well the ODMantic encoders ( BSON_TYPES_ENCODERS ). Custom encoders example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from datetime import datetime from odmantic.bson import BSON_TYPES_ENCODERS , BaseBSONModel , ObjectId class M ( BaseBSONModel ): id : ObjectId date : datetime class Config : json_encoders = { ** BSON_TYPES_ENCODERS , datetime : lambda dt : dt . year , } print ( M ( id = ObjectId (), date = datetime . utcnow ()) . json ()) #> {\"id\": \"5fa3378c8fde3766574d874d\", \"date\": 2020} An issue that would simplify this behavior has been opened: pydantic#2024 Accessing the underlying pydantic model \u00b6 Each ODMantic Model contain a pure version of the pydantic model used to build the ODMantic Model. This Pydantic model can be accessed in the __pydantic_model__ class attribute of the ODMantic Model/EmbeddedModel.","title":"Usage with Pydantic"},{"location":"usage_pydantic/#usage-with-pydantic","text":"","title":"Usage with Pydantic"},{"location":"usage_pydantic/#defining-models-with-bson-fields","text":"You might need to define pure Pydantic models which include BSON fields. To that end, you can use the BaseBSONModel as the base class of your Pydantic models. This class adds the JSON encoders required to handle the BSON fields. Also, you will have to use the bson equivalent types defined in the odmantic.bson module. Those types, add a validation logic to the native types from the bson module. Custom json_encoders with BaseBSONModel If you want to specify additional json encoders, with a Pydantic model containing BSON fields, you will need to pass as well the ODMantic encoders ( BSON_TYPES_ENCODERS ). Custom encoders example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from datetime import datetime from odmantic.bson import BSON_TYPES_ENCODERS , BaseBSONModel , ObjectId class M ( BaseBSONModel ): id : ObjectId date : datetime class Config : json_encoders = { ** BSON_TYPES_ENCODERS , datetime : lambda dt : dt . year , } print ( M ( id = ObjectId (), date = datetime . utcnow ()) . json ()) #> {\"id\": \"5fa3378c8fde3766574d874d\", \"date\": 2020} An issue that would simplify this behavior has been opened: pydantic#2024","title":"Defining models with BSON Fields"},{"location":"usage_pydantic/#accessing-the-underlying-pydantic-model","text":"Each ODMantic Model contain a pure version of the pydantic model used to build the ODMantic Model. This Pydantic model can be accessed in the __pydantic_model__ class attribute of the ODMantic Model/EmbeddedModel.","title":"Accessing the underlying pydantic model"},{"location":"api_reference/bson/","text":"This module provides helpers to build Pydantic Models containing BSON objects. Pydantic model helpers \u00b6 odmantic.bson.BaseBSONModel \u00b6 Bases: BaseModel Equivalent of pydantic.BaseModel supporting BSON types encoding. If you want to apply other custom JSON encoders, you'll need to use BSON_TYPES_ENCODERS directly. Source code in odmantic/bson.py 189 190 191 192 193 194 195 196 197 class BaseBSONModel ( BaseModel ): \"\"\"Equivalent of `pydantic.BaseModel` supporting BSON types encoding. If you want to apply other custom JSON encoders, you'll need to use [BSON_TYPES_ENCODERS][odmantic.bson.BSON_TYPES_ENCODERS] directly. \"\"\" class Config : json_encoders = BSON_TYPES_ENCODERS odmantic . bson . BSON_TYPES_ENCODERS = { bson . ObjectId : str , bson . decimal128 . Decimal128 : lambda x : x . to_decimal (), bson . regex . Regex : lambda x : x . pattern } module-attribute \u00b6 Encoders required to encode BSON fields (can be used in the Pydantic Model's Config.json_encoders parameter). See pydantic: JSON Encoders for more details. Pydantic type helpers \u00b6 Those helpers inherit directly from their respective bson types. They add the field validation logic required by Pydantic to work with them. On top of this, the appropriate JSON schemas are generated for them. odmantic.bson.ObjectId \u00b6 Bases: bson . ObjectId Source code in odmantic/bson.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ObjectId ( bson . ObjectId ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ \"5f85f36d6dfecacc68428a46\" , \"ffffffffffffffffffffffff\" ], example = \"5f85f36d6dfecacc68428a46\" , type = \"string\" , ) @classmethod def validate ( cls , v : Any ) -> bson . ObjectId : if isinstance ( v , ( bson . ObjectId , cls )): return v if isinstance ( v , str ) and bson . ObjectId . is_valid ( v ): return bson . ObjectId ( v ) raise TypeError ( \"invalid ObjectId specified\" ) odmantic.bson.Int64 \u00b6 Bases: bson . int64 . Int64 Source code in odmantic/bson.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Int64 ( bson . int64 . Int64 ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ 2147483649 ], type = \"number\" ) @classmethod def validate ( cls , v : Any ) -> bson . int64 . Int64 : if isinstance ( v , bson . int64 . Int64 ): return v a = int_validator ( v ) return bson . int64 . Int64 ( a ) odmantic.bson.Decimal128 \u00b6 Bases: bson . decimal128 . Decimal128 Source code in odmantic/bson.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Decimal128 ( bson . decimal128 . Decimal128 ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ 214.7483649 ], example = 214.7483649 , type = \"number\" ) @classmethod def validate ( cls , v : Any ) -> bson . decimal128 . Decimal128 : if isinstance ( v , bson . decimal128 . Decimal128 ): return v a = decimal_validator ( v ) return bson . decimal128 . Decimal128 ( a ) odmantic.bson.Binary \u00b6 Bases: bson . binary . Binary Source code in odmantic/bson.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class Binary ( bson . binary . Binary ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( type = \"string\" , format = \"binary\" ) @classmethod def validate ( cls , v : Any ) -> bson . binary . Binary : if isinstance ( v , bson . binary . Binary ): return v a = bytes_validator ( v ) return bson . binary . Binary ( a ) odmantic.bson.Regex \u00b6 Bases: bson . regex . Regex Source code in odmantic/bson.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class Regex ( bson . regex . Regex ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ r \"^Foo\" ], example = r \"^Foo\" , type = \"string\" , format = \"binary\" ) @classmethod def validate ( cls , v : Any ) -> bson . regex . Regex : if isinstance ( v , bson . regex . Regex ): return v a = pattern_validator ( v ) return bson . regex . Regex ( a . pattern )","title":"odmantic.bson"},{"location":"api_reference/bson/#pydantic-model-helpers","text":"","title":"Pydantic model helpers"},{"location":"api_reference/bson/#odmantic.bson.BaseBSONModel","text":"Bases: BaseModel Equivalent of pydantic.BaseModel supporting BSON types encoding. If you want to apply other custom JSON encoders, you'll need to use BSON_TYPES_ENCODERS directly. Source code in odmantic/bson.py 189 190 191 192 193 194 195 196 197 class BaseBSONModel ( BaseModel ): \"\"\"Equivalent of `pydantic.BaseModel` supporting BSON types encoding. If you want to apply other custom JSON encoders, you'll need to use [BSON_TYPES_ENCODERS][odmantic.bson.BSON_TYPES_ENCODERS] directly. \"\"\" class Config : json_encoders = BSON_TYPES_ENCODERS","title":"BaseBSONModel"},{"location":"api_reference/bson/#odmantic.bson.BSON_TYPES_ENCODERS","text":"Encoders required to encode BSON fields (can be used in the Pydantic Model's Config.json_encoders parameter). See pydantic: JSON Encoders for more details.","title":"BSON_TYPES_ENCODERS"},{"location":"api_reference/bson/#pydantic-type-helpers","text":"Those helpers inherit directly from their respective bson types. They add the field validation logic required by Pydantic to work with them. On top of this, the appropriate JSON schemas are generated for them.","title":"Pydantic type helpers"},{"location":"api_reference/bson/#odmantic.bson.ObjectId","text":"Bases: bson . ObjectId Source code in odmantic/bson.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ObjectId ( bson . ObjectId ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ \"5f85f36d6dfecacc68428a46\" , \"ffffffffffffffffffffffff\" ], example = \"5f85f36d6dfecacc68428a46\" , type = \"string\" , ) @classmethod def validate ( cls , v : Any ) -> bson . ObjectId : if isinstance ( v , ( bson . ObjectId , cls )): return v if isinstance ( v , str ) and bson . ObjectId . is_valid ( v ): return bson . ObjectId ( v ) raise TypeError ( \"invalid ObjectId specified\" )","title":"ObjectId"},{"location":"api_reference/bson/#odmantic.bson.Int64","text":"Bases: bson . int64 . Int64 Source code in odmantic/bson.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Int64 ( bson . int64 . Int64 ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ 2147483649 ], type = \"number\" ) @classmethod def validate ( cls , v : Any ) -> bson . int64 . Int64 : if isinstance ( v , bson . int64 . Int64 ): return v a = int_validator ( v ) return bson . int64 . Int64 ( a )","title":"Int64"},{"location":"api_reference/bson/#odmantic.bson.Decimal128","text":"Bases: bson . decimal128 . Decimal128 Source code in odmantic/bson.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Decimal128 ( bson . decimal128 . Decimal128 ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ 214.7483649 ], example = 214.7483649 , type = \"number\" ) @classmethod def validate ( cls , v : Any ) -> bson . decimal128 . Decimal128 : if isinstance ( v , bson . decimal128 . Decimal128 ): return v a = decimal_validator ( v ) return bson . decimal128 . Decimal128 ( a )","title":"Decimal128"},{"location":"api_reference/bson/#odmantic.bson.Binary","text":"Bases: bson . binary . Binary Source code in odmantic/bson.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class Binary ( bson . binary . Binary ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( type = \"string\" , format = \"binary\" ) @classmethod def validate ( cls , v : Any ) -> bson . binary . Binary : if isinstance ( v , bson . binary . Binary ): return v a = bytes_validator ( v ) return bson . binary . Binary ( a )","title":"Binary"},{"location":"api_reference/bson/#odmantic.bson.Regex","text":"Bases: bson . regex . Regex Source code in odmantic/bson.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class Regex ( bson . regex . Regex ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ r \"^Foo\" ], example = r \"^Foo\" , type = \"string\" , format = \"binary\" ) @classmethod def validate ( cls , v : Any ) -> bson . regex . Regex : if isinstance ( v , bson . regex . Regex ): return v a = pattern_validator ( v ) return bson . regex . Regex ( a . pattern )","title":"Regex"},{"location":"api_reference/engine/","text":"odmantic.engine.AIOEngine \u00b6 The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. Source code in odmantic/engine.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 class AIOEngine : \"\"\"The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. \"\"\" def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\"Engine constructor. Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 ValueError --> \"\"\" # https://docs.mongodb.com/manual/reference/limits/#naming-restrictions forbidden_characters = _FORBIDDEN_DATABASE_CHARACTERS . intersection ( set ( database ) ) if len ( forbidden_characters ) > 0 : raise ValueError ( f \"database name cannot contain: { ' ' . join ( forbidden_characters ) } \" ) if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database_name = database self . database = motor_client [ self . database_name ] def get_collection ( self , model : Type [ ModelType ]) -> AsyncIOMotorCollection : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ] @staticmethod def _build_query ( * queries : Union [ QueryExpression , Dict , bool ]) -> QueryExpression : if len ( queries ) == 0 : return QueryExpression () for query in queries : if isinstance ( query , bool ): raise TypeError ( \"cannot build query using booleans\" ) queries = cast ( Tuple [ Union [ QueryExpression , Dict ], ... ], queries ) if len ( queries ) == 1 : return QueryExpression ( queries [ 0 ]) return and_ ( * queries ) @staticmethod def _cascade_find_pipeline ( model : Type [ ModelType ], doc_namespace : str = \"\" ) -> List [ Dict ]: \"\"\"Recursively build the find pipeline for model.\"\"\" pipeline : List [ Dict ] = [] for ref_field_name in model . __references__ : odm_reference = cast ( ODMReference , model . __odm_fields__ [ ref_field_name ]) pipeline . extend ( [ { \"$lookup\" : { \"from\" : odm_reference . model . __collection__ , \"let\" : { \"foreign_id\" : f \"$ { odm_reference . key_name } \" }, \"pipeline\" : [ { \"$match\" : { \"$expr\" : { \"$eq\" : [ \"$_id\" , \"$$foreign_id\" ]} } }, * AIOEngine . _cascade_find_pipeline ( odm_reference . model , doc_namespace = f \" { doc_namespace }{ ref_field_name } .\" , ), ], \"as\" : odm_reference . key_name # FIXME if ref field name is an existing key_name ? } }, { # Preserves document with unbound references \"$unwind\" : { \"path\" : f \"$ { odm_reference . key_name } \" , \"preserveNullAndEmptyArrays\" : True , } }, ] ) return pipeline @staticmethod def _build_sort_expression ( sort_field : Union [ FieldProxy , SortExpression ] ) -> SortExpression : return ( SortExpression ({ + sort_field : 1 }) if not isinstance ( sort_field , SortExpression ) else sort_field ) @classmethod def _validate_sort_argument ( cls , sort : Any ) -> Optional [ SortExpression ]: if sort is None : return None if isinstance ( sort , tuple ): for sorted_field in sort : if not isinstance ( sorted_field , ( FieldProxy , SortExpression )): raise TypeError ( \"sort elements have to be Model fields or asc, desc descriptors\" ) sort_expression : Dict = {} for sort_field in sort : sort_expression . update ( cls . _build_sort_expression ( sort_field )) return SortExpression ( sort_expression ) if not isinstance ( sort , ( FieldProxy , SortExpression )): raise TypeError ( \"sort has to be a Model field or \" \"asc, desc descriptors or a tuple of these\" ) return cls . _build_sort_expression ( sort ) def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) sort_expression = self . _validate_sort_argument ( sort ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if sort_expression is not None : pipeline . append ({ \"$sort\" : sort_expression }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor ) async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin, sort : Optional [ Any ] = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , sort = sort , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ] async def _save ( self , instance : ModelType , session : AsyncIOMotorClientSession ) -> ModelType : \"\"\"Perform an atomic save operation in the specified session\"\"\" save_tasks = [] for ref_field_name in instance . __references__ : sub_instance = cast ( Model , getattr ( instance , ref_field_name )) save_tasks . append ( self . _save ( sub_instance , session )) await gather ( * save_tasks ) fields_to_update = ( instance . __fields_modified__ | instance . __mutable_fields__ ) - set ([ instance . __primary_field__ ]) if len ( fields_to_update ) > 0 : doc = instance . doc ( include = fields_to_update ) collection = self . get_collection ( type ( instance )) await collection . update_one ( { \"_id\" : getattr ( instance , instance . __primary_field__ )}, { \"$set\" : doc }, upsert = True , ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance async def save ( self , instance : ModelType ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) return instance async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance ) async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ] ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = AIOEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count ) __init__ ( motor_client = None , database = 'test' ) \u00b6 Engine constructor. Parameters: Name Type Description Default motor_client AsyncIOMotorClient instance of an AsyncIO motor client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\"Engine constructor. Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 ValueError --> \"\"\" # https://docs.mongodb.com/manual/reference/limits/#naming-restrictions forbidden_characters = _FORBIDDEN_DATABASE_CHARACTERS . intersection ( set ( database ) ) if len ( forbidden_characters ) > 0 : raise ValueError ( f \"database name cannot contain: { ' ' . join ( forbidden_characters ) } \" ) if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database_name = database self . database = motor_client [ self . database_name ] count ( model , * queries ) async \u00b6 Get the count of documents matching a query Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filters to apply () Returns: Type Description int number of document matching the query Source code in odmantic/engine.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ] ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = AIOEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count ) delete ( instance ) async \u00b6 Delete an instance from the database Parameters: Name Type Description Default instance ModelType the instance to delete required Raises: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance ) find ( model , * queries , sort = None , skip = 0 , limit = None ) \u00b6 Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None skip int number of document to skip 0 limit Optional [ int ] maximum number of instance fetched None Raises: Type Description DocumentParsingError unable to parse one of the resulting documents Returns: Type Description AIOCursor [ ModelType ] odmantic.engine.AIOCursor of the query Source code in odmantic/engine.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) sort_expression = self . _validate_sort_argument ( sort ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if sort_expression is not None : pipeline . append ({ \"$sort\" : sort_expression }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor ) find_one ( model , * queries , sort = None ) async \u00b6 Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None Raises: Type Description DocumentParsingError unable to parse the resulting document Returns: Type Description Optional [ ModelType ] the fetched instance if found otherwise None Source code in odmantic/engine.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin, sort : Optional [ Any ] = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , sort = sort , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ] get_collection ( model ) \u00b6 Get the motor collection associated to a Model. Parameters: Name Type Description Default model Type [ ModelType ] model class required Returns: Type Description AsyncIOMotorCollection the AsyncIO motor collection object Source code in odmantic/engine.py 118 119 120 121 122 123 124 125 126 127 def get_collection ( self , model : Type [ ModelType ]) -> AsyncIOMotorCollection : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ] save ( instance ) async \u00b6 Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ModelType instance to persist required Returns: Type Description ModelType the saved instance NOTE The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 async def save ( self , instance : ModelType ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) return instance save_all ( instances ) async \u00b6 Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence [ ModelType ] instances to persist required Returns: Type Description List [ ModelType ] the saved instances NOTE The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances odmantic.engine.AIOCursor \u00b6 Bases: Generic [ ModelType ] , AsyncIterable [ ModelType ] , Awaitable [ List [ ModelType ]] This object has to be built from the odmantic.engine.AIOEngine.find method. An AIOCursor object support multiple async operations async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models Source code in odmantic/engine.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class AIOCursor ( Generic [ ModelType ], AsyncIterable [ ModelType ], Awaitable [ List [ ModelType ]] ): \"\"\"This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: - **async for**: asynchronously iterate over the query results - **await** : when awaited it will return a list of the fetched models \"\"\" def __init__ ( self , model : Type [ ModelType ], motor_cursor : AsyncIOMotorCursor ): self . _model = model self . _motor_cursor = motor_cursor self . _results : Optional [ List [ ModelType ]] = None def _parse_document ( self , raw_doc : Dict ) -> ModelType : instance = self . _model . parse_doc ( raw_doc ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance def __await__ ( self ) -> Generator [ None , None , List [ ModelType ]]: if self . _results is not None : return self . _results raw_docs = yield from self . _motor_cursor . to_list ( length = None ) . __await__ () instances = [] for raw_doc in raw_docs : instances . append ( self . _parse_document ( raw_doc )) yield self . _results = instances return instances async def __aiter__ ( self ) -> AsyncGenerator [ ModelType , None ]: if self . _results is not None : for res in self . _results : yield res return results = [] async for raw_doc in self . _motor_cursor : instance = self . _parse_document ( raw_doc ) results . append ( instance ) yield instance self . _results = results","title":"odmantic.engine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine","text":"The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. Source code in odmantic/engine.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 class AIOEngine : \"\"\"The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. \"\"\" def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\"Engine constructor. Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 ValueError --> \"\"\" # https://docs.mongodb.com/manual/reference/limits/#naming-restrictions forbidden_characters = _FORBIDDEN_DATABASE_CHARACTERS . intersection ( set ( database ) ) if len ( forbidden_characters ) > 0 : raise ValueError ( f \"database name cannot contain: { ' ' . join ( forbidden_characters ) } \" ) if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database_name = database self . database = motor_client [ self . database_name ] def get_collection ( self , model : Type [ ModelType ]) -> AsyncIOMotorCollection : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ] @staticmethod def _build_query ( * queries : Union [ QueryExpression , Dict , bool ]) -> QueryExpression : if len ( queries ) == 0 : return QueryExpression () for query in queries : if isinstance ( query , bool ): raise TypeError ( \"cannot build query using booleans\" ) queries = cast ( Tuple [ Union [ QueryExpression , Dict ], ... ], queries ) if len ( queries ) == 1 : return QueryExpression ( queries [ 0 ]) return and_ ( * queries ) @staticmethod def _cascade_find_pipeline ( model : Type [ ModelType ], doc_namespace : str = \"\" ) -> List [ Dict ]: \"\"\"Recursively build the find pipeline for model.\"\"\" pipeline : List [ Dict ] = [] for ref_field_name in model . __references__ : odm_reference = cast ( ODMReference , model . __odm_fields__ [ ref_field_name ]) pipeline . extend ( [ { \"$lookup\" : { \"from\" : odm_reference . model . __collection__ , \"let\" : { \"foreign_id\" : f \"$ { odm_reference . key_name } \" }, \"pipeline\" : [ { \"$match\" : { \"$expr\" : { \"$eq\" : [ \"$_id\" , \"$$foreign_id\" ]} } }, * AIOEngine . _cascade_find_pipeline ( odm_reference . model , doc_namespace = f \" { doc_namespace }{ ref_field_name } .\" , ), ], \"as\" : odm_reference . key_name # FIXME if ref field name is an existing key_name ? } }, { # Preserves document with unbound references \"$unwind\" : { \"path\" : f \"$ { odm_reference . key_name } \" , \"preserveNullAndEmptyArrays\" : True , } }, ] ) return pipeline @staticmethod def _build_sort_expression ( sort_field : Union [ FieldProxy , SortExpression ] ) -> SortExpression : return ( SortExpression ({ + sort_field : 1 }) if not isinstance ( sort_field , SortExpression ) else sort_field ) @classmethod def _validate_sort_argument ( cls , sort : Any ) -> Optional [ SortExpression ]: if sort is None : return None if isinstance ( sort , tuple ): for sorted_field in sort : if not isinstance ( sorted_field , ( FieldProxy , SortExpression )): raise TypeError ( \"sort elements have to be Model fields or asc, desc descriptors\" ) sort_expression : Dict = {} for sort_field in sort : sort_expression . update ( cls . _build_sort_expression ( sort_field )) return SortExpression ( sort_expression ) if not isinstance ( sort , ( FieldProxy , SortExpression )): raise TypeError ( \"sort has to be a Model field or \" \"asc, desc descriptors or a tuple of these\" ) return cls . _build_sort_expression ( sort ) def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) sort_expression = self . _validate_sort_argument ( sort ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if sort_expression is not None : pipeline . append ({ \"$sort\" : sort_expression }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor ) async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin, sort : Optional [ Any ] = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , sort = sort , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ] async def _save ( self , instance : ModelType , session : AsyncIOMotorClientSession ) -> ModelType : \"\"\"Perform an atomic save operation in the specified session\"\"\" save_tasks = [] for ref_field_name in instance . __references__ : sub_instance = cast ( Model , getattr ( instance , ref_field_name )) save_tasks . append ( self . _save ( sub_instance , session )) await gather ( * save_tasks ) fields_to_update = ( instance . __fields_modified__ | instance . __mutable_fields__ ) - set ([ instance . __primary_field__ ]) if len ( fields_to_update ) > 0 : doc = instance . doc ( include = fields_to_update ) collection = self . get_collection ( type ( instance )) await collection . update_one ( { \"_id\" : getattr ( instance , instance . __primary_field__ )}, { \"$set\" : doc }, upsert = True , ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance async def save ( self , instance : ModelType ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) return instance async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance ) async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ] ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = AIOEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count )","title":"AIOEngine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.__init__","text":"Engine constructor. Parameters: Name Type Description Default motor_client AsyncIOMotorClient instance of an AsyncIO motor client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\"Engine constructor. Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 ValueError --> \"\"\" # https://docs.mongodb.com/manual/reference/limits/#naming-restrictions forbidden_characters = _FORBIDDEN_DATABASE_CHARACTERS . intersection ( set ( database ) ) if len ( forbidden_characters ) > 0 : raise ValueError ( f \"database name cannot contain: { ' ' . join ( forbidden_characters ) } \" ) if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database_name = database self . database = motor_client [ self . database_name ]","title":"__init__()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.count","text":"Get the count of documents matching a query Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filters to apply () Returns: Type Description int number of document matching the query Source code in odmantic/engine.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ] ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = AIOEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count )","title":"count()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.delete","text":"Delete an instance from the database Parameters: Name Type Description Default instance ModelType the instance to delete required Raises: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance )","title":"delete()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find","text":"Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None skip int number of document to skip 0 limit Optional [ int ] maximum number of instance fetched None Raises: Type Description DocumentParsingError unable to parse one of the resulting documents Returns: Type Description AIOCursor [ ModelType ] odmantic.engine.AIOCursor of the query Source code in odmantic/engine.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) sort_expression = self . _validate_sort_argument ( sort ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if sort_expression is not None : pipeline . append ({ \"$sort\" : sort_expression }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor )","title":"find()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find_one","text":"Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None Raises: Type Description DocumentParsingError unable to parse the resulting document Returns: Type Description Optional [ ModelType ] the fetched instance if found otherwise None Source code in odmantic/engine.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin, sort : Optional [ Any ] = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , sort = sort , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ]","title":"find_one()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.get_collection","text":"Get the motor collection associated to a Model. Parameters: Name Type Description Default model Type [ ModelType ] model class required Returns: Type Description AsyncIOMotorCollection the AsyncIO motor collection object Source code in odmantic/engine.py 118 119 120 121 122 123 124 125 126 127 def get_collection ( self , model : Type [ ModelType ]) -> AsyncIOMotorCollection : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ]","title":"get_collection()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save","text":"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ModelType instance to persist required Returns: Type Description ModelType the saved instance NOTE The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 async def save ( self , instance : ModelType ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) return instance","title":"save()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save_all","text":"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence [ ModelType ] instances to persist required Returns: Type Description List [ ModelType ] the saved instances NOTE The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances","title":"save_all()"},{"location":"api_reference/engine/#odmantic.engine.AIOCursor","text":"Bases: Generic [ ModelType ] , AsyncIterable [ ModelType ] , Awaitable [ List [ ModelType ]] This object has to be built from the odmantic.engine.AIOEngine.find method. An AIOCursor object support multiple async operations async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models Source code in odmantic/engine.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class AIOCursor ( Generic [ ModelType ], AsyncIterable [ ModelType ], Awaitable [ List [ ModelType ]] ): \"\"\"This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: - **async for**: asynchronously iterate over the query results - **await** : when awaited it will return a list of the fetched models \"\"\" def __init__ ( self , model : Type [ ModelType ], motor_cursor : AsyncIOMotorCursor ): self . _model = model self . _motor_cursor = motor_cursor self . _results : Optional [ List [ ModelType ]] = None def _parse_document ( self , raw_doc : Dict ) -> ModelType : instance = self . _model . parse_doc ( raw_doc ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance def __await__ ( self ) -> Generator [ None , None , List [ ModelType ]]: if self . _results is not None : return self . _results raw_docs = yield from self . _motor_cursor . to_list ( length = None ) . __await__ () instances = [] for raw_doc in raw_docs : instances . append ( self . _parse_document ( raw_doc )) yield self . _results = instances return instances async def __aiter__ ( self ) -> AsyncGenerator [ ModelType , None ]: if self . _results is not None : for res in self . _results : yield res return results = [] async for raw_doc in self . _motor_cursor : instance = self . _parse_document ( raw_doc ) results . append ( instance ) yield instance self . _results = results","title":"AIOCursor"},{"location":"api_reference/exceptions/","text":"odmantic.exceptions.BaseEngineException \u00b6 Bases: Exception Base Exception raised by the engine while operating with the database. Source code in odmantic/exceptions.py 12 13 14 15 16 17 class BaseEngineException ( Exception , metaclass = ABCMeta ): \"\"\"Base Exception raised by the engine while operating with the database.\"\"\" def __init__ ( self , message : str , model : Type [ \"Model\" ]): self . model : Type [ \"Model\" ] = model super () . __init__ ( message ) odmantic.exceptions.DocumentNotFoundError \u00b6 Bases: BaseEngineException The targetted document has not been found by the engine. Attributes: Name Type Description instance Model the instance that has not been found Source code in odmantic/exceptions.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class DocumentNotFoundError ( BaseEngineException ): \"\"\"The targetted document has not been found by the engine. Attributes: instance: the instance that has not been found \"\"\" def __init__ ( self , instance : \"Model\" ): self . instance : \"Model\" = instance super () . __init__ ( f \"Document not found for : { type ( instance ) . __name__ } . \" f \"Instance: { self . instance } \" , type ( instance ), ) odmantic.exceptions.DocumentParsingError \u00b6 Bases: ValidationError Unable to parse the document into an instance. Inherits from the ValidationError defined by Pydantic. Attributes: Name Type Description model Union [ Type [ Model ], Type [ EmbeddedModel ]] model which could not be instanciated Source code in odmantic/exceptions.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class DocumentParsingError ( ValidationError ): \"\"\"Unable to parse the document into an instance. Inherits from the `ValidationError` defined by Pydantic. Attributes: model (Union[Type[Model],Type[EmbeddedModel]]): model which could not be instanciated \"\"\" def __init__ ( self , errors : Sequence [ ErrorList ], model : Type [ \"_BaseODMModel\" ], primary_value : Any , ): super () . __init__ ( errors , model ) self . model : Union [ Type [ \"Model\" ], Type [ \"EmbeddedModel\" ]] self . primary_value = primary_value def __str__ ( self ) -> str : from odmantic import Model if issubclass ( self . model , Model ): return ( f \" { super () . __str__ () } \\n \" f \"( { self . model . __name__ } instance details:\" f \" { self . model . __primary_field__ } = { repr ( self . primary_value ) } )\" ) return super () . __str__ ()","title":"odmantic.exceptions"},{"location":"api_reference/exceptions/#odmantic.exceptions.BaseEngineException","text":"Bases: Exception Base Exception raised by the engine while operating with the database. Source code in odmantic/exceptions.py 12 13 14 15 16 17 class BaseEngineException ( Exception , metaclass = ABCMeta ): \"\"\"Base Exception raised by the engine while operating with the database.\"\"\" def __init__ ( self , message : str , model : Type [ \"Model\" ]): self . model : Type [ \"Model\" ] = model super () . __init__ ( message )","title":"BaseEngineException"},{"location":"api_reference/exceptions/#odmantic.exceptions.DocumentNotFoundError","text":"Bases: BaseEngineException The targetted document has not been found by the engine. Attributes: Name Type Description instance Model the instance that has not been found Source code in odmantic/exceptions.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class DocumentNotFoundError ( BaseEngineException ): \"\"\"The targetted document has not been found by the engine. Attributes: instance: the instance that has not been found \"\"\" def __init__ ( self , instance : \"Model\" ): self . instance : \"Model\" = instance super () . __init__ ( f \"Document not found for : { type ( instance ) . __name__ } . \" f \"Instance: { self . instance } \" , type ( instance ), )","title":"DocumentNotFoundError"},{"location":"api_reference/exceptions/#odmantic.exceptions.DocumentParsingError","text":"Bases: ValidationError Unable to parse the document into an instance. Inherits from the ValidationError defined by Pydantic. Attributes: Name Type Description model Union [ Type [ Model ], Type [ EmbeddedModel ]] model which could not be instanciated Source code in odmantic/exceptions.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class DocumentParsingError ( ValidationError ): \"\"\"Unable to parse the document into an instance. Inherits from the `ValidationError` defined by Pydantic. Attributes: model (Union[Type[Model],Type[EmbeddedModel]]): model which could not be instanciated \"\"\" def __init__ ( self , errors : Sequence [ ErrorList ], model : Type [ \"_BaseODMModel\" ], primary_value : Any , ): super () . __init__ ( errors , model ) self . model : Union [ Type [ \"Model\" ], Type [ \"EmbeddedModel\" ]] self . primary_value = primary_value def __str__ ( self ) -> str : from odmantic import Model if issubclass ( self . model , Model ): return ( f \" { super () . __str__ () } \\n \" f \"( { self . model . __name__ } instance details:\" f \" { self . model . __primary_field__ } = { repr ( self . primary_value ) } )\" ) return super () . __str__ ()","title":"DocumentParsingError"},{"location":"api_reference/fastapi/","text":"odmantic.fastapi.AIOEngineDependency \u00b6 Bases: fastapi . params . Depends AIOEngine FastAPI Dependency. Warning Deprecated since v0.2.0, more details . Internally caches the AIOEngine instance to avoid creating a new client on each request. Sample usage: app = FastAPI () EngineD = AIOEngineDependency () @app . get ( \"/\" ) async def get ( engine : AIOEngine = EngineD ): await engine . find ( ... ) await engine . save ( ... ) Source code in odmantic/fastapi.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class AIOEngineDependency ( fastapi . params . Depends ): \"\"\"AIOEngine FastAPI Dependency. Warning: Deprecated since v0.2.0, [more details](https://art049.github.io/odmantic/usage_fastapi/#building-the-engine). Internally caches the AIOEngine instance to avoid creating a new client on each request. Sample usage: ```python app = FastAPI() EngineD = AIOEngineDependency() @app.get(\"/\") async def get(engine: AIOEngine = EngineD): await engine.find(...) await engine.save(...) ``` \"\"\" def __init__ ( self , mongo_uri : Optional [ str ] = None , database : str = \"test\" ) -> None : \"\"\"Dependency initializer for AIOEngine. Args: mongo_uri: mongo_uri that should be used for creating the motor client database: database to use \"\"\" super () . __init__ ( dependency = self ) self . mongo_uri = mongo_uri self . database = database self . engine : Optional [ AIOEngine ] = None warnings . warn ( \"the AIOEngineDependency object is deprecated, see \" \"https://art049.github.io/odmantic/usage_fastapi/#building-the-engine \" \"for more details.\" , DeprecationWarning , ) async def __call__ ( self ) -> AIOEngine : if self . engine is None : motor_client = None if self . mongo_uri is not None : motor_client = AsyncIOMotorClient ( self . mongo_uri ) self . engine = AIOEngine ( motor_client , self . database ) return self . engine __init__ ( mongo_uri = None , database = 'test' ) \u00b6 Dependency initializer for AIOEngine. Parameters: Name Type Description Default mongo_uri Optional [ str ] mongo_uri that should be used for creating the motor client None database str database to use 'test' Source code in odmantic/fastapi.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , mongo_uri : Optional [ str ] = None , database : str = \"test\" ) -> None : \"\"\"Dependency initializer for AIOEngine. Args: mongo_uri: mongo_uri that should be used for creating the motor client database: database to use \"\"\" super () . __init__ ( dependency = self ) self . mongo_uri = mongo_uri self . database = database self . engine : Optional [ AIOEngine ] = None warnings . warn ( \"the AIOEngineDependency object is deprecated, see \" \"https://art049.github.io/odmantic/usage_fastapi/#building-the-engine \" \"for more details.\" , DeprecationWarning , )","title":"odmantic.fastapi"},{"location":"api_reference/fastapi/#odmantic.fastapi.AIOEngineDependency","text":"Bases: fastapi . params . Depends AIOEngine FastAPI Dependency. Warning Deprecated since v0.2.0, more details . Internally caches the AIOEngine instance to avoid creating a new client on each request. Sample usage: app = FastAPI () EngineD = AIOEngineDependency () @app . get ( \"/\" ) async def get ( engine : AIOEngine = EngineD ): await engine . find ( ... ) await engine . save ( ... ) Source code in odmantic/fastapi.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class AIOEngineDependency ( fastapi . params . Depends ): \"\"\"AIOEngine FastAPI Dependency. Warning: Deprecated since v0.2.0, [more details](https://art049.github.io/odmantic/usage_fastapi/#building-the-engine). Internally caches the AIOEngine instance to avoid creating a new client on each request. Sample usage: ```python app = FastAPI() EngineD = AIOEngineDependency() @app.get(\"/\") async def get(engine: AIOEngine = EngineD): await engine.find(...) await engine.save(...) ``` \"\"\" def __init__ ( self , mongo_uri : Optional [ str ] = None , database : str = \"test\" ) -> None : \"\"\"Dependency initializer for AIOEngine. Args: mongo_uri: mongo_uri that should be used for creating the motor client database: database to use \"\"\" super () . __init__ ( dependency = self ) self . mongo_uri = mongo_uri self . database = database self . engine : Optional [ AIOEngine ] = None warnings . warn ( \"the AIOEngineDependency object is deprecated, see \" \"https://art049.github.io/odmantic/usage_fastapi/#building-the-engine \" \"for more details.\" , DeprecationWarning , ) async def __call__ ( self ) -> AIOEngine : if self . engine is None : motor_client = None if self . mongo_uri is not None : motor_client = AsyncIOMotorClient ( self . mongo_uri ) self . engine = AIOEngine ( motor_client , self . database ) return self . engine","title":"AIOEngineDependency"},{"location":"api_reference/fastapi/#odmantic.fastapi.AIOEngineDependency.__init__","text":"Dependency initializer for AIOEngine. Parameters: Name Type Description Default mongo_uri Optional [ str ] mongo_uri that should be used for creating the motor client None database str database to use 'test' Source code in odmantic/fastapi.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , mongo_uri : Optional [ str ] = None , database : str = \"test\" ) -> None : \"\"\"Dependency initializer for AIOEngine. Args: mongo_uri: mongo_uri that should be used for creating the motor client database: database to use \"\"\" super () . __init__ ( dependency = self ) self . mongo_uri = mongo_uri self . database = database self . engine : Optional [ AIOEngine ] = None warnings . warn ( \"the AIOEngineDependency object is deprecated, see \" \"https://art049.github.io/odmantic/usage_fastapi/#building-the-engine \" \"for more details.\" , DeprecationWarning , )","title":"__init__()"},{"location":"api_reference/field/","text":"odmantic . field . Field ( default = Undefined , * , key_name = None , primary_field = False , default_factory = None , title = None , description = None , const = None , gt = None , ge = None , lt = None , le = None , multiple_of = None , min_items = None , max_items = None , min_length = None , max_length = None , regex = None , ** extra ) \u00b6 Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields ( int , float , Decimal ) and some apply only to str . Tip The main additions of ODMantic to the regular pydantic Field are the key_name and the primary_field options. Warning If both default and default_factory are set, an error is raised. Warning primary_field can't be used along with key_name since the key_name will be set to _id . Parameters: Name Type Description Default default Any since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis ( ... ) to indicate the field has no default value Undefined key_name Optional [ str ] the name to use in the the mongo document structure None primary_field bool this field should be considered as a primary key. False default_factory Optional [ NoArgAnyCallable ] callable that will be called when a default value is needed for this field. None title Optional [ str ] can be any string, used in the schema None description Optional [ str ] can be any string, used in the schema None const Optional [ bool ] this field is required and must take it's default value None gt Optional [ float ] only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword None ge Optional [ float ] only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword None lt Optional [ float ] only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword None le Optional [ float ] only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a maximum validation keyword None multiple_of Optional [ float ] only applies to numbers, requires the field to be \"a multiple of \". The schema will have a multipleOf validation keyword None min_items Optional [ int ] only applies to sequences, requires the field to have a minimum item count. None max_items Optional [ int ] only applies to sequences, requires the field to have a maximum item count. None min_length Optional [ int ] only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword None max_length Optional [ int ] only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword None regex Optional [ str ] only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a pattern validation keyword None **extra Any any additional keyword arguments will be added as is to the schema {} Source code in odmantic/field.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def Field ( default : Any = Undefined , * , key_name : Optional [ str ] = None , primary_field : bool = False , default_factory : Optional [ NoArgAnyCallable ] = None , # alias: str = None, # FIXME not supported yet title : Optional [ str ] = None , description : Optional [ str ] = None , const : Optional [ bool ] = None , gt : Optional [ float ] = None , ge : Optional [ float ] = None , lt : Optional [ float ] = None , le : Optional [ float ] = None , multiple_of : Optional [ float ] = None , min_items : Optional [ int ] = None , max_items : Optional [ int ] = None , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , regex : Optional [ str ] = None , ** extra : Any , ) -> Any : \"\"\"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. Tip: The main additions of ODMantic to the regular pydantic `Field` are the `key_name` and the `primary_field` options. Warning: If both `default` and `default_factory` are set, an error is raised. Warning: `primary_field` can't be used along with `key_name` since the key_name will be set to `_id`. Args: default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field has no default value key_name: the name to use in the the mongo document structure primary_field: this field should be considered as a primary key. default_factory: callable that will be called when a default value is needed for this field. title: can be any string, used in the schema description: can be any string, used in the schema const: this field is required and *must* take it's default value gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an ``exclusiveMinimum`` validation keyword ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a ``minimum`` validation keyword lt: only applies to numbers, requires the field to be \"less than\". The schema will have an ``exclusiveMaximum`` validation keyword le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a ``maximum`` validation keyword multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a ``multipleOf`` validation keyword min_items: only applies to sequences, requires the field to have a minimum item count. max_items: only applies to sequences, requires the field to have a maximum item count. min_length: only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword max_length: only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a ``pattern`` validation keyword **extra: any additional keyword arguments will be added as is to the schema <!--- # noqa: DAR201 # noqa: DAR003 # noqa: DAR401 # noqa: DAR101 --> \"\"\" # Perform casts on optional fields to avoid incompatibility due to the strict # optional mypy setting pydantic_field = PDField ( default , default_factory = default_factory , # alias=alias, # FIXME check aliases compatibility title = cast ( str , title ), description = cast ( str , description ), const = cast ( bool , const ), gt = cast ( float , gt ), ge = cast ( float , ge ), lt = cast ( float , lt ), le = cast ( float , le ), multiple_of = cast ( float , multiple_of ), min_items = cast ( int , min_items ), max_items = cast ( int , max_items ), min_length = cast ( int , min_length ), max_length = cast ( int , max_length ), regex = cast ( str , regex ), ** extra , ) if primary_field : if key_name is not None and key_name != \"_id\" : raise ValueError ( \"cannot specify a primary field with a custom key_name,\" \"key_name='_id' enforced\" ) else : key_name = \"_id\" elif key_name == \"_id\" : raise ValueError ( \"cannot specify key_name='_id' without defining the field as primary\" ) return ODMFieldInfo ( pydantic_field_info = pydantic_field , primary_field = primary_field , key_name = key_name , )","title":"odmantic.field"},{"location":"api_reference/field/#odmantic.field.Field","text":"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields ( int , float , Decimal ) and some apply only to str . Tip The main additions of ODMantic to the regular pydantic Field are the key_name and the primary_field options. Warning If both default and default_factory are set, an error is raised. Warning primary_field can't be used along with key_name since the key_name will be set to _id . Parameters: Name Type Description Default default Any since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis ( ... ) to indicate the field has no default value Undefined key_name Optional [ str ] the name to use in the the mongo document structure None primary_field bool this field should be considered as a primary key. False default_factory Optional [ NoArgAnyCallable ] callable that will be called when a default value is needed for this field. None title Optional [ str ] can be any string, used in the schema None description Optional [ str ] can be any string, used in the schema None const Optional [ bool ] this field is required and must take it's default value None gt Optional [ float ] only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword None ge Optional [ float ] only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword None lt Optional [ float ] only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword None le Optional [ float ] only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a maximum validation keyword None multiple_of Optional [ float ] only applies to numbers, requires the field to be \"a multiple of \". The schema will have a multipleOf validation keyword None min_items Optional [ int ] only applies to sequences, requires the field to have a minimum item count. None max_items Optional [ int ] only applies to sequences, requires the field to have a maximum item count. None min_length Optional [ int ] only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword None max_length Optional [ int ] only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword None regex Optional [ str ] only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a pattern validation keyword None **extra Any any additional keyword arguments will be added as is to the schema {} Source code in odmantic/field.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def Field ( default : Any = Undefined , * , key_name : Optional [ str ] = None , primary_field : bool = False , default_factory : Optional [ NoArgAnyCallable ] = None , # alias: str = None, # FIXME not supported yet title : Optional [ str ] = None , description : Optional [ str ] = None , const : Optional [ bool ] = None , gt : Optional [ float ] = None , ge : Optional [ float ] = None , lt : Optional [ float ] = None , le : Optional [ float ] = None , multiple_of : Optional [ float ] = None , min_items : Optional [ int ] = None , max_items : Optional [ int ] = None , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , regex : Optional [ str ] = None , ** extra : Any , ) -> Any : \"\"\"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. Tip: The main additions of ODMantic to the regular pydantic `Field` are the `key_name` and the `primary_field` options. Warning: If both `default` and `default_factory` are set, an error is raised. Warning: `primary_field` can't be used along with `key_name` since the key_name will be set to `_id`. Args: default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field has no default value key_name: the name to use in the the mongo document structure primary_field: this field should be considered as a primary key. default_factory: callable that will be called when a default value is needed for this field. title: can be any string, used in the schema description: can be any string, used in the schema const: this field is required and *must* take it's default value gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an ``exclusiveMinimum`` validation keyword ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a ``minimum`` validation keyword lt: only applies to numbers, requires the field to be \"less than\". The schema will have an ``exclusiveMaximum`` validation keyword le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a ``maximum`` validation keyword multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a ``multipleOf`` validation keyword min_items: only applies to sequences, requires the field to have a minimum item count. max_items: only applies to sequences, requires the field to have a maximum item count. min_length: only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword max_length: only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a ``pattern`` validation keyword **extra: any additional keyword arguments will be added as is to the schema <!--- # noqa: DAR201 # noqa: DAR003 # noqa: DAR401 # noqa: DAR101 --> \"\"\" # Perform casts on optional fields to avoid incompatibility due to the strict # optional mypy setting pydantic_field = PDField ( default , default_factory = default_factory , # alias=alias, # FIXME check aliases compatibility title = cast ( str , title ), description = cast ( str , description ), const = cast ( bool , const ), gt = cast ( float , gt ), ge = cast ( float , ge ), lt = cast ( float , lt ), le = cast ( float , le ), multiple_of = cast ( float , multiple_of ), min_items = cast ( int , min_items ), max_items = cast ( int , max_items ), min_length = cast ( int , min_length ), max_length = cast ( int , max_length ), regex = cast ( str , regex ), ** extra , ) if primary_field : if key_name is not None and key_name != \"_id\" : raise ValueError ( \"cannot specify a primary field with a custom key_name,\" \"key_name='_id' enforced\" ) else : key_name = \"_id\" elif key_name == \"_id\" : raise ValueError ( \"cannot specify key_name='_id' without defining the field as primary\" ) return ODMFieldInfo ( pydantic_field_info = pydantic_field , primary_field = primary_field , key_name = key_name , )","title":"Field()"},{"location":"api_reference/model/","text":"odmantic.model._BaseODMModel \u00b6 Bases: pydantic . BaseModel Base class for Model and EmbeddedModel . Warning This internal class should never be instanciated directly. Source code in odmantic/model.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 class _BaseODMModel ( pydantic . BaseModel , metaclass = ABCMeta ): \"\"\"Base class for [Model][odmantic.model.Model] and [EmbeddedModel][odmantic.model.EmbeddedModel]. !!! warning This internal class should never be instanciated directly. \"\"\" if TYPE_CHECKING : __odm_fields__ : ClassVar [ Dict [ str , ODMBaseField ]] = {} __bson_serialized_fields__ : ClassVar [ FrozenSet [ str ]] = frozenset () __mutable_fields__ : ClassVar [ FrozenSet [ str ]] = frozenset () __references__ : ClassVar [ Tuple [ str , ... ]] = () __pydantic_model__ : ClassVar [ Type [ BaseBSONModel ]] __fields_modified__ : Set [ str ] = set () __slots__ = ( \"__fields_modified__\" ,) def __init__ ( self , ** data : Any ): super () . __init__ ( ** data ) object . __setattr__ ( self , \"__fields_modified__\" , set ( self . __odm_fields__ . keys ())) @classmethod def validate ( cls : Type [ BaseT ], value : Any ) -> BaseT : if isinstance ( value , cls ): # Do not copy the object as done in pydantic # This enable to keep the same python object return value return super () . validate ( value ) def __repr_args__ ( self ) -> \"ReprArgs\" : # Place the id field first in the repr string args = list ( super () . __repr_args__ ()) id_arg = next (( arg for arg in args if arg [ 0 ] == \"id\" ), None ) if id_arg is None : return args args . remove ( id_arg ) args = [ id_arg ] + args return args def copy ( self : BaseT , * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , update : Optional [ \"DictStrAny\" ] = None , deep : bool = False , ) -> BaseT : \"\"\"Duplicate a model, optionally choose which fields to include, exclude and change. Danger: The data is not validated before creating the new model: **you should trust this data**. Arguments: include: fields to include in new model exclude: fields to exclude from new model, as with values this takes precedence over include update: values to change/add in the new model. deep: set to `True` to make a deep copy of the model Note: The `include` and `exclude` kwargs are only affecting the copied data, not filtering the update object. Returns: new model instance \"\"\" copied = super () . copy ( include = include , exclude = exclude , update = update , deep = deep # type: ignore ) object . __setattr__ ( copied , \"__fields_modified__\" , set ( copied . __fields__ )) return copied def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : \"\"\"Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the **fields set** will be applied by default. Args: patch_object: object containing the values to update include: fields to include from the `patch_object` (include all fields if `None`) exclude: fields to exclude from the `patch_object`, this takes precedence over include exclude_unset: only update fields explicitly set in the patch object (only applies to Pydantic models) exclude_defaults: only update fields that are different from their default value in the patch object (only applies to Pydantic models) exclude_none: only update fields different from None in the patch object (only applies to Pydantic models) Raises: ValidationError: the modifications would make the instance invalid <!-- #noqa: DAR402 ValidationError --> \"\"\" if isinstance ( patch_object , BaseModel ): patch_dict = patch_object . dict ( include = include , # type: ignore exclude = exclude , # type: ignore exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) else : odm_fields = set ( self . __odm_fields__ . keys ()) patch_dict = {} for k , v in patch_object . items (): if include is not None and k not in include : continue if exclude is not None and k in exclude : continue if k not in odm_fields : continue patch_dict [ k ] = v patched_instance_dict = { ** self . dict (), ** patch_dict } # FIXME: improve performance by only running updated field validators and then # model validators patched_instance = self . validate ( patched_instance_dict ) for name , new_value in patched_instance . __dict__ . items (): if self . __dict__ [ name ] != new_value : # Manually change the field to avoid running the validators again self . __dict__ [ name ] = new_value self . __fields_set__ . add ( name ) self . __fields_modified__ . add ( name ) def __setattr__ ( self , name : str , value : Any ) -> None : super () . __setattr__ ( name , value ) self . __fields_modified__ . add ( name ) def dict ( # type: ignore # Missing deprecated/ unsupported parameters self , * , include : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , by_alias : bool = False , # FIXME when aliases are supported ) -> \"DictStrAny\" : \"\"\"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Args: include: fields to include (include all fields if `None`) exclude: fields to exclude this takes precedence over include exclude_unset: only include fields explicitly set exclude_defaults: only include fields that are different from their default value exclude_none: only include fields different from `None` by_alias: **not supported yet** Returns: the dictionary representation of the instance \"\"\" return super () . dict ( include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, every fields will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc : Dict [ str , Any ] = {} for field_name , field in self . __odm_fields__ . items (): if include is not None and field_name not in include : continue if isinstance ( field , ODMReference ): doc [ field . key_name ] = raw_doc [ field_name ][ \"id\" ] else : if field_name in self . __bson_serialized_fields__ : doc [ field . key_name ] = self . __fields__ [ field_name ] . type_ . __bson__ ( raw_doc [ field_name ] ) else : doc [ field . key_name ] = raw_doc [ field_name ] return doc @classmethod def parse_doc ( cls : Type [ BaseT ], raw_doc : Dict ) -> BaseT : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Raises: DocumentParsingError: the specified document is invalid Returns: an instance of the Model class this method is called on. \"\"\" errors , obj = cls . _parse_doc_to_obj ( raw_doc ) if len ( errors ) > 0 : raise DocumentParsingError ( errors = [ errors ], model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) try : instance = cls . parse_obj ( obj ) except ValidationError as e : raise DocumentParsingError ( errors = e . raw_errors , # type: ignore model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) return instance @classmethod def _parse_doc_to_obj ( cls : Type [ BaseT ], raw_doc : Dict , base_loc : Tuple [ str , ... ] = () ) -> Tuple [ ErrorList , Dict [ str , Any ]]: errors : ErrorList = [] obj : Dict [ str , Any ] = {} for field_name , field in cls . __odm_fields__ . items (): if isinstance ( field , ODMReference ): sub_doc = raw_doc . get ( field . key_name ) if sub_doc is None : errors . append ( ErrorWrapper ( exc = ReferencedDocumentNotFoundError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) else : sub_errors , sub_obj = field . model . _parse_doc_to_obj ( sub_doc , base_loc = base_loc + ( field_name ,) ) errors . extend ( sub_errors ) obj [ field_name ] = sub_obj else : field = cast ( Union [ ODMField , ODMEmbedded ], field ) value = raw_doc . get ( field . key_name , Undefined ) if value is Undefined and not field . is_required_in_doc (): value = field . get_default_importing_value () if value is Undefined : errors . append ( ErrorWrapper ( exc = KeyNotFoundInDocumentError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) else : obj [ field_name ] = value return errors , obj parse_doc ( raw_doc ) classmethod \u00b6 Parse a BSON document into an instance of the Model Parameters: Name Type Description Default raw_doc Dict document to parse (as Dict) required Raises: Type Description DocumentParsingError the specified document is invalid Returns: Type Description BaseT an instance of the Model class this method is called on. Source code in odmantic/model.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 @classmethod def parse_doc ( cls : Type [ BaseT ], raw_doc : Dict ) -> BaseT : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Raises: DocumentParsingError: the specified document is invalid Returns: an instance of the Model class this method is called on. \"\"\" errors , obj = cls . _parse_doc_to_obj ( raw_doc ) if len ( errors ) > 0 : raise DocumentParsingError ( errors = [ errors ], model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) try : instance = cls . parse_obj ( obj ) except ValidationError as e : raise DocumentParsingError ( errors = e . raw_errors , # type: ignore model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) return instance doc ( include = None ) \u00b6 Generate a document representation of the instance (as a dictionary). Parameters: Name Type Description Default include Optional [ AbstractSetIntStr ] field that should be included; if None, every fields will be included None Returns: Type Description Dict [ str , Any ] the document associated to the instance Source code in odmantic/model.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, every fields will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc : Dict [ str , Any ] = {} for field_name , field in self . __odm_fields__ . items (): if include is not None and field_name not in include : continue if isinstance ( field , ODMReference ): doc [ field . key_name ] = raw_doc [ field_name ][ \"id\" ] else : if field_name in self . __bson_serialized_fields__ : doc [ field . key_name ] = self . __fields__ [ field_name ] . type_ . __bson__ ( raw_doc [ field_name ] ) else : doc [ field . key_name ] = raw_doc [ field_name ] return doc update ( patch_object , * , include = None , exclude = None , exclude_unset = True , exclude_defaults = False , exclude_none = False ) \u00b6 Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the fields set will be applied by default. Parameters: Name Type Description Default patch_object Union [ BaseModel , Dict [ str , Any ]] object containing the values to update required include Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to include from the patch_object (include all fields if None ) None exclude Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to exclude from the patch_object , this takes precedence over include None exclude_unset bool only update fields explicitly set in the patch object (only applies to Pydantic models) True exclude_defaults bool only update fields that are different from their default value in the patch object (only applies to Pydantic models) False exclude_none bool only update fields different from None in the patch object (only applies to Pydantic models) False Raises: Type Description ValidationError the modifications would make the instance invalid Source code in odmantic/model.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : \"\"\"Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the **fields set** will be applied by default. Args: patch_object: object containing the values to update include: fields to include from the `patch_object` (include all fields if `None`) exclude: fields to exclude from the `patch_object`, this takes precedence over include exclude_unset: only update fields explicitly set in the patch object (only applies to Pydantic models) exclude_defaults: only update fields that are different from their default value in the patch object (only applies to Pydantic models) exclude_none: only update fields different from None in the patch object (only applies to Pydantic models) Raises: ValidationError: the modifications would make the instance invalid <!-- #noqa: DAR402 ValidationError --> \"\"\" if isinstance ( patch_object , BaseModel ): patch_dict = patch_object . dict ( include = include , # type: ignore exclude = exclude , # type: ignore exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) else : odm_fields = set ( self . __odm_fields__ . keys ()) patch_dict = {} for k , v in patch_object . items (): if include is not None and k not in include : continue if exclude is not None and k in exclude : continue if k not in odm_fields : continue patch_dict [ k ] = v patched_instance_dict = { ** self . dict (), ** patch_dict } # FIXME: improve performance by only running updated field validators and then # model validators patched_instance = self . validate ( patched_instance_dict ) for name , new_value in patched_instance . __dict__ . items (): if self . __dict__ [ name ] != new_value : # Manually change the field to avoid running the validators again self . __dict__ [ name ] = new_value self . __fields_set__ . add ( name ) self . __fields_modified__ . add ( name ) copy ( * , include = None , exclude = None , update = None , deep = False ) \u00b6 Duplicate a model, optionally choose which fields to include, exclude and change. Danger The data is not validated before creating the new model: you should trust this data . Parameters: Name Type Description Default include Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to include in new model None exclude Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to exclude from new model, as with values this takes precedence over include None update Optional [ DictStrAny ] values to change/add in the new model. None deep bool set to True to make a deep copy of the model False Note The include and exclude kwargs are only affecting the copied data, not filtering the update object. Returns: Type Description BaseT new model instance Source code in odmantic/model.py 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 def copy ( self : BaseT , * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , update : Optional [ \"DictStrAny\" ] = None , deep : bool = False , ) -> BaseT : \"\"\"Duplicate a model, optionally choose which fields to include, exclude and change. Danger: The data is not validated before creating the new model: **you should trust this data**. Arguments: include: fields to include in new model exclude: fields to exclude from new model, as with values this takes precedence over include update: values to change/add in the new model. deep: set to `True` to make a deep copy of the model Note: The `include` and `exclude` kwargs are only affecting the copied data, not filtering the update object. Returns: new model instance \"\"\" copied = super () . copy ( include = include , exclude = exclude , update = update , deep = deep # type: ignore ) object . __setattr__ ( copied , \"__fields_modified__\" , set ( copied . __fields__ )) return copied dict ( * , include = None , exclude = None , exclude_unset = False , exclude_defaults = False , exclude_none = False , by_alias = False ) \u00b6 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Parameters: Name Type Description Default include Union [ AbstractSetIntStr , MappingIntStrAny ] fields to include (include all fields if None ) None exclude Union [ AbstractSetIntStr , MappingIntStrAny ] fields to exclude this takes precedence over include None exclude_unset bool only include fields explicitly set False exclude_defaults bool only include fields that are different from their default value False exclude_none bool only include fields different from None False by_alias bool not supported yet False Returns: Type Description DictStrAny the dictionary representation of the instance Source code in odmantic/model.py 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 def dict ( # type: ignore # Missing deprecated/ unsupported parameters self , * , include : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , by_alias : bool = False , # FIXME when aliases are supported ) -> \"DictStrAny\" : \"\"\"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Args: include: fields to include (include all fields if `None`) exclude: fields to exclude this takes precedence over include exclude_unset: only include fields explicitly set exclude_defaults: only include fields that are different from their default value exclude_none: only include fields different from `None` by_alias: **not supported yet** Returns: the dictionary representation of the instance \"\"\" return super () . dict ( include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) odmantic.model.Model \u00b6 Bases: _BaseODMModel Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the __collection__ class variable in the model classes. Source code in odmantic/model.py 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 class Model ( _BaseODMModel , metaclass = ModelMetaclass ): \"\"\"Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the `__collection__` class variable in the model classes. \"\"\" if TYPE_CHECKING : __collection__ : ClassVar [ str ] = \"\" __primary_field__ : ClassVar [ str ] = \"\" id : Union [ ObjectId , Any ] # TODO fix basic id field typing def __setattr__ ( self , name : str , value : Any ) -> None : if name == self . __primary_field__ : # TODO implement raise NotImplementedError ( \"Reassigning a new primary key is not supported yet\" ) super () . __setattr__ ( name , value ) def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : is_primary_field_in_patch = ( isinstance ( patch_object , BaseModel ) and self . __primary_field__ in patch_object . __fields__ ) or ( isinstance ( patch_object , dict ) and self . __primary_field__ in patch_object ) if is_primary_field_in_patch : if ( include is None and ( exclude is None or self . __primary_field__ not in exclude ) ) or ( include is not None and self . __primary_field__ in include and ( exclude is None or self . __primary_field__ not in exclude ) ): raise ValueError ( \"Updating the primary key is not supported. \" \"See the copy method if you want to modify the primary field.\" ) return super () . update ( patch_object , include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) odmantic.model.EmbeddedModel \u00b6 Bases: _BaseODMModel Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model. Source code in odmantic/model.py 797 798 799 800 801 802 class EmbeddedModel ( _BaseODMModel , metaclass = EmbeddedModelMetaclass ): \"\"\"Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model. \"\"\"","title":"odmantic.model"},{"location":"api_reference/model/#odmantic.model._BaseODMModel","text":"Bases: pydantic . BaseModel Base class for Model and EmbeddedModel . Warning This internal class should never be instanciated directly. Source code in odmantic/model.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 class _BaseODMModel ( pydantic . BaseModel , metaclass = ABCMeta ): \"\"\"Base class for [Model][odmantic.model.Model] and [EmbeddedModel][odmantic.model.EmbeddedModel]. !!! warning This internal class should never be instanciated directly. \"\"\" if TYPE_CHECKING : __odm_fields__ : ClassVar [ Dict [ str , ODMBaseField ]] = {} __bson_serialized_fields__ : ClassVar [ FrozenSet [ str ]] = frozenset () __mutable_fields__ : ClassVar [ FrozenSet [ str ]] = frozenset () __references__ : ClassVar [ Tuple [ str , ... ]] = () __pydantic_model__ : ClassVar [ Type [ BaseBSONModel ]] __fields_modified__ : Set [ str ] = set () __slots__ = ( \"__fields_modified__\" ,) def __init__ ( self , ** data : Any ): super () . __init__ ( ** data ) object . __setattr__ ( self , \"__fields_modified__\" , set ( self . __odm_fields__ . keys ())) @classmethod def validate ( cls : Type [ BaseT ], value : Any ) -> BaseT : if isinstance ( value , cls ): # Do not copy the object as done in pydantic # This enable to keep the same python object return value return super () . validate ( value ) def __repr_args__ ( self ) -> \"ReprArgs\" : # Place the id field first in the repr string args = list ( super () . __repr_args__ ()) id_arg = next (( arg for arg in args if arg [ 0 ] == \"id\" ), None ) if id_arg is None : return args args . remove ( id_arg ) args = [ id_arg ] + args return args def copy ( self : BaseT , * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , update : Optional [ \"DictStrAny\" ] = None , deep : bool = False , ) -> BaseT : \"\"\"Duplicate a model, optionally choose which fields to include, exclude and change. Danger: The data is not validated before creating the new model: **you should trust this data**. Arguments: include: fields to include in new model exclude: fields to exclude from new model, as with values this takes precedence over include update: values to change/add in the new model. deep: set to `True` to make a deep copy of the model Note: The `include` and `exclude` kwargs are only affecting the copied data, not filtering the update object. Returns: new model instance \"\"\" copied = super () . copy ( include = include , exclude = exclude , update = update , deep = deep # type: ignore ) object . __setattr__ ( copied , \"__fields_modified__\" , set ( copied . __fields__ )) return copied def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : \"\"\"Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the **fields set** will be applied by default. Args: patch_object: object containing the values to update include: fields to include from the `patch_object` (include all fields if `None`) exclude: fields to exclude from the `patch_object`, this takes precedence over include exclude_unset: only update fields explicitly set in the patch object (only applies to Pydantic models) exclude_defaults: only update fields that are different from their default value in the patch object (only applies to Pydantic models) exclude_none: only update fields different from None in the patch object (only applies to Pydantic models) Raises: ValidationError: the modifications would make the instance invalid <!-- #noqa: DAR402 ValidationError --> \"\"\" if isinstance ( patch_object , BaseModel ): patch_dict = patch_object . dict ( include = include , # type: ignore exclude = exclude , # type: ignore exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) else : odm_fields = set ( self . __odm_fields__ . keys ()) patch_dict = {} for k , v in patch_object . items (): if include is not None and k not in include : continue if exclude is not None and k in exclude : continue if k not in odm_fields : continue patch_dict [ k ] = v patched_instance_dict = { ** self . dict (), ** patch_dict } # FIXME: improve performance by only running updated field validators and then # model validators patched_instance = self . validate ( patched_instance_dict ) for name , new_value in patched_instance . __dict__ . items (): if self . __dict__ [ name ] != new_value : # Manually change the field to avoid running the validators again self . __dict__ [ name ] = new_value self . __fields_set__ . add ( name ) self . __fields_modified__ . add ( name ) def __setattr__ ( self , name : str , value : Any ) -> None : super () . __setattr__ ( name , value ) self . __fields_modified__ . add ( name ) def dict ( # type: ignore # Missing deprecated/ unsupported parameters self , * , include : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , by_alias : bool = False , # FIXME when aliases are supported ) -> \"DictStrAny\" : \"\"\"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Args: include: fields to include (include all fields if `None`) exclude: fields to exclude this takes precedence over include exclude_unset: only include fields explicitly set exclude_defaults: only include fields that are different from their default value exclude_none: only include fields different from `None` by_alias: **not supported yet** Returns: the dictionary representation of the instance \"\"\" return super () . dict ( include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, every fields will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc : Dict [ str , Any ] = {} for field_name , field in self . __odm_fields__ . items (): if include is not None and field_name not in include : continue if isinstance ( field , ODMReference ): doc [ field . key_name ] = raw_doc [ field_name ][ \"id\" ] else : if field_name in self . __bson_serialized_fields__ : doc [ field . key_name ] = self . __fields__ [ field_name ] . type_ . __bson__ ( raw_doc [ field_name ] ) else : doc [ field . key_name ] = raw_doc [ field_name ] return doc @classmethod def parse_doc ( cls : Type [ BaseT ], raw_doc : Dict ) -> BaseT : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Raises: DocumentParsingError: the specified document is invalid Returns: an instance of the Model class this method is called on. \"\"\" errors , obj = cls . _parse_doc_to_obj ( raw_doc ) if len ( errors ) > 0 : raise DocumentParsingError ( errors = [ errors ], model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) try : instance = cls . parse_obj ( obj ) except ValidationError as e : raise DocumentParsingError ( errors = e . raw_errors , # type: ignore model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) return instance @classmethod def _parse_doc_to_obj ( cls : Type [ BaseT ], raw_doc : Dict , base_loc : Tuple [ str , ... ] = () ) -> Tuple [ ErrorList , Dict [ str , Any ]]: errors : ErrorList = [] obj : Dict [ str , Any ] = {} for field_name , field in cls . __odm_fields__ . items (): if isinstance ( field , ODMReference ): sub_doc = raw_doc . get ( field . key_name ) if sub_doc is None : errors . append ( ErrorWrapper ( exc = ReferencedDocumentNotFoundError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) else : sub_errors , sub_obj = field . model . _parse_doc_to_obj ( sub_doc , base_loc = base_loc + ( field_name ,) ) errors . extend ( sub_errors ) obj [ field_name ] = sub_obj else : field = cast ( Union [ ODMField , ODMEmbedded ], field ) value = raw_doc . get ( field . key_name , Undefined ) if value is Undefined and not field . is_required_in_doc (): value = field . get_default_importing_value () if value is Undefined : errors . append ( ErrorWrapper ( exc = KeyNotFoundInDocumentError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) else : obj [ field_name ] = value return errors , obj","title":"_BaseODMModel"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.parse_doc","text":"Parse a BSON document into an instance of the Model Parameters: Name Type Description Default raw_doc Dict document to parse (as Dict) required Raises: Type Description DocumentParsingError the specified document is invalid Returns: Type Description BaseT an instance of the Model class this method is called on. Source code in odmantic/model.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 @classmethod def parse_doc ( cls : Type [ BaseT ], raw_doc : Dict ) -> BaseT : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Raises: DocumentParsingError: the specified document is invalid Returns: an instance of the Model class this method is called on. \"\"\" errors , obj = cls . _parse_doc_to_obj ( raw_doc ) if len ( errors ) > 0 : raise DocumentParsingError ( errors = [ errors ], model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) try : instance = cls . parse_obj ( obj ) except ValidationError as e : raise DocumentParsingError ( errors = e . raw_errors , # type: ignore model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) return instance","title":"parse_doc()"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.doc","text":"Generate a document representation of the instance (as a dictionary). Parameters: Name Type Description Default include Optional [ AbstractSetIntStr ] field that should be included; if None, every fields will be included None Returns: Type Description Dict [ str , Any ] the document associated to the instance Source code in odmantic/model.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, every fields will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc : Dict [ str , Any ] = {} for field_name , field in self . __odm_fields__ . items (): if include is not None and field_name not in include : continue if isinstance ( field , ODMReference ): doc [ field . key_name ] = raw_doc [ field_name ][ \"id\" ] else : if field_name in self . __bson_serialized_fields__ : doc [ field . key_name ] = self . __fields__ [ field_name ] . type_ . __bson__ ( raw_doc [ field_name ] ) else : doc [ field . key_name ] = raw_doc [ field_name ] return doc","title":"doc()"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.update","text":"Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the fields set will be applied by default. Parameters: Name Type Description Default patch_object Union [ BaseModel , Dict [ str , Any ]] object containing the values to update required include Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to include from the patch_object (include all fields if None ) None exclude Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to exclude from the patch_object , this takes precedence over include None exclude_unset bool only update fields explicitly set in the patch object (only applies to Pydantic models) True exclude_defaults bool only update fields that are different from their default value in the patch object (only applies to Pydantic models) False exclude_none bool only update fields different from None in the patch object (only applies to Pydantic models) False Raises: Type Description ValidationError the modifications would make the instance invalid Source code in odmantic/model.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : \"\"\"Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the **fields set** will be applied by default. Args: patch_object: object containing the values to update include: fields to include from the `patch_object` (include all fields if `None`) exclude: fields to exclude from the `patch_object`, this takes precedence over include exclude_unset: only update fields explicitly set in the patch object (only applies to Pydantic models) exclude_defaults: only update fields that are different from their default value in the patch object (only applies to Pydantic models) exclude_none: only update fields different from None in the patch object (only applies to Pydantic models) Raises: ValidationError: the modifications would make the instance invalid <!-- #noqa: DAR402 ValidationError --> \"\"\" if isinstance ( patch_object , BaseModel ): patch_dict = patch_object . dict ( include = include , # type: ignore exclude = exclude , # type: ignore exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) else : odm_fields = set ( self . __odm_fields__ . keys ()) patch_dict = {} for k , v in patch_object . items (): if include is not None and k not in include : continue if exclude is not None and k in exclude : continue if k not in odm_fields : continue patch_dict [ k ] = v patched_instance_dict = { ** self . dict (), ** patch_dict } # FIXME: improve performance by only running updated field validators and then # model validators patched_instance = self . validate ( patched_instance_dict ) for name , new_value in patched_instance . __dict__ . items (): if self . __dict__ [ name ] != new_value : # Manually change the field to avoid running the validators again self . __dict__ [ name ] = new_value self . __fields_set__ . add ( name ) self . __fields_modified__ . add ( name )","title":"update()"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.copy","text":"Duplicate a model, optionally choose which fields to include, exclude and change. Danger The data is not validated before creating the new model: you should trust this data . Parameters: Name Type Description Default include Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to include in new model None exclude Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to exclude from new model, as with values this takes precedence over include None update Optional [ DictStrAny ] values to change/add in the new model. None deep bool set to True to make a deep copy of the model False Note The include and exclude kwargs are only affecting the copied data, not filtering the update object. Returns: Type Description BaseT new model instance Source code in odmantic/model.py 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 def copy ( self : BaseT , * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , update : Optional [ \"DictStrAny\" ] = None , deep : bool = False , ) -> BaseT : \"\"\"Duplicate a model, optionally choose which fields to include, exclude and change. Danger: The data is not validated before creating the new model: **you should trust this data**. Arguments: include: fields to include in new model exclude: fields to exclude from new model, as with values this takes precedence over include update: values to change/add in the new model. deep: set to `True` to make a deep copy of the model Note: The `include` and `exclude` kwargs are only affecting the copied data, not filtering the update object. Returns: new model instance \"\"\" copied = super () . copy ( include = include , exclude = exclude , update = update , deep = deep # type: ignore ) object . __setattr__ ( copied , \"__fields_modified__\" , set ( copied . __fields__ )) return copied","title":"copy()"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Parameters: Name Type Description Default include Union [ AbstractSetIntStr , MappingIntStrAny ] fields to include (include all fields if None ) None exclude Union [ AbstractSetIntStr , MappingIntStrAny ] fields to exclude this takes precedence over include None exclude_unset bool only include fields explicitly set False exclude_defaults bool only include fields that are different from their default value False exclude_none bool only include fields different from None False by_alias bool not supported yet False Returns: Type Description DictStrAny the dictionary representation of the instance Source code in odmantic/model.py 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 def dict ( # type: ignore # Missing deprecated/ unsupported parameters self , * , include : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , by_alias : bool = False , # FIXME when aliases are supported ) -> \"DictStrAny\" : \"\"\"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Args: include: fields to include (include all fields if `None`) exclude: fields to exclude this takes precedence over include exclude_unset: only include fields explicitly set exclude_defaults: only include fields that are different from their default value exclude_none: only include fields different from `None` by_alias: **not supported yet** Returns: the dictionary representation of the instance \"\"\" return super () . dict ( include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , )","title":"dict()"},{"location":"api_reference/model/#odmantic.model.Model","text":"Bases: _BaseODMModel Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the __collection__ class variable in the model classes. Source code in odmantic/model.py 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 class Model ( _BaseODMModel , metaclass = ModelMetaclass ): \"\"\"Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the `__collection__` class variable in the model classes. \"\"\" if TYPE_CHECKING : __collection__ : ClassVar [ str ] = \"\" __primary_field__ : ClassVar [ str ] = \"\" id : Union [ ObjectId , Any ] # TODO fix basic id field typing def __setattr__ ( self , name : str , value : Any ) -> None : if name == self . __primary_field__ : # TODO implement raise NotImplementedError ( \"Reassigning a new primary key is not supported yet\" ) super () . __setattr__ ( name , value ) def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : is_primary_field_in_patch = ( isinstance ( patch_object , BaseModel ) and self . __primary_field__ in patch_object . __fields__ ) or ( isinstance ( patch_object , dict ) and self . __primary_field__ in patch_object ) if is_primary_field_in_patch : if ( include is None and ( exclude is None or self . __primary_field__ not in exclude ) ) or ( include is not None and self . __primary_field__ in include and ( exclude is None or self . __primary_field__ not in exclude ) ): raise ValueError ( \"Updating the primary key is not supported. \" \"See the copy method if you want to modify the primary field.\" ) return super () . update ( patch_object , include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , )","title":"Model"},{"location":"api_reference/model/#odmantic.model.EmbeddedModel","text":"Bases: _BaseODMModel Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model. Source code in odmantic/model.py 797 798 799 800 801 802 class EmbeddedModel ( _BaseODMModel , metaclass = EmbeddedModelMetaclass ): \"\"\"Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model. \"\"\"","title":"EmbeddedModel"},{"location":"api_reference/query/","text":"odmantic.query.QueryExpression \u00b6 Bases: Dict [ str , Any ] Base object used to build queries. All comparison and logical operators returns QueryExpression objects. The | and & operators are supported for respectively the or and the and logical operators. Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Source code in odmantic/query.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class QueryExpression ( Dict [ str , Any ]): \"\"\"Base object used to build queries. All comparison and logical operators returns `QueryExpression` objects. The `|` and `&` operators are supported for respectively the [or][odmantic.query.or_] and the [and][odmantic.query.and_] logical operators. Warning: When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. \"\"\" def __repr__ ( self ) -> str : parent_repr = super () . __repr__ () if parent_repr == \" {} \" : parent_repr = \"\" return f \"QueryExpression( { parent_repr } )\" def __or__ ( self , other : \"QueryExpression\" ) -> \"QueryExpression\" : return or_ ( self , other ) def __and__ ( self , other : \"QueryExpression\" ) -> \"QueryExpression\" : return and_ ( self , other ) Logical Operators \u00b6 odmantic . query . and_ ( * elements ) \u00b6 Logical AND operation between multiple QueryExpression objects. Source code in odmantic/query.py 40 41 42 def and_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **AND** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$and\" : elements }) odmantic . query . or_ ( * elements ) \u00b6 Logical OR operation between multiple QueryExpression objects. Source code in odmantic/query.py 45 46 47 def or_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **OR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$or\" : elements }) odmantic . query . nor_ ( * elements ) \u00b6 Logical NOR operation between multiple QueryExpression objects. Source code in odmantic/query.py 50 51 52 def nor_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **NOR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$nor\" : elements }) Comparison Operators \u00b6 odmantic . query . eq ( field , value ) \u00b6 Equality comparison operator. Source code in odmantic/query.py 71 72 73 def eq ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Equality comparison operator.\"\"\" return _cmp_expression ( field , \"$eq\" , value ) odmantic . query . ne ( field , value ) \u00b6 Inequality comparison operator (includes documents not containing the field). Source code in odmantic/query.py 76 77 78 def ne ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Inequality comparison operator (includes documents not containing the field).\"\"\" return _cmp_expression ( field , \"$ne\" , value ) odmantic . query . gt ( field , value ) \u00b6 Greater than (strict) comparison operator (i.e. >). Source code in odmantic/query.py 81 82 83 def gt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than (strict) comparison operator (i.e. >).\"\"\" return _cmp_expression ( field , \"$gt\" , value ) odmantic . query . gte ( field , value ) \u00b6 Greater than or equal comparison operator (i.e. >=). Source code in odmantic/query.py 86 87 88 def gte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than or equal comparison operator (i.e. >=).\"\"\" return _cmp_expression ( field , \"$gte\" , value ) odmantic . query . lt ( field , value ) \u00b6 Less than (strict) comparison operator (i.e. <). Source code in odmantic/query.py 91 92 93 def lt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than (strict) comparison operator (i.e. <).\"\"\" return _cmp_expression ( field , \"$lt\" , value ) odmantic . query . lte ( field , value ) \u00b6 Less than or equal comparison operator (i.e. <=). Source code in odmantic/query.py 96 97 98 def lte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than or equal comparison operator (i.e. <=).\"\"\" return _cmp_expression ( field , \"$lte\" , value ) odmantic . query . in_ ( field , sequence ) \u00b6 Select instances where field is contained in sequence . Source code in odmantic/query.py 101 102 103 def in_ ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$in\" , sequence ) odmantic . query . not_in ( field , sequence ) \u00b6 Select instances where field is not contained in sequence . Source code in odmantic/query.py 106 107 108 def not_in ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is **not** contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$nin\" , sequence ) odmantic . query . match ( field , pattern ) \u00b6 Select instances where field matches the pattern regular expression. Source code in odmantic/query.py 111 112 113 114 115 116 117 118 119 def match ( field : FieldProxyAny , pattern : Union [ Pattern , str ]) -> QueryExpression : \"\"\"Select instances where `field` matches the `pattern` regular expression.\"\"\" # FIXME might create incompatibilities # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not if isinstance ( pattern , str ): r = re . compile ( pattern ) else : r = pattern return QueryExpression ({ + field : r }) Sort helpers \u00b6 odmantic.query.SortExpression \u00b6 Bases: Dict [ str , Literal [-1, 1]] Base object used to build sort queries. Source code in odmantic/query.py 122 123 124 125 126 127 128 129 class SortExpression ( Dict [ str , Literal [ - 1 , 1 ]]): \"\"\"Base object used to build sort queries.\"\"\" def __repr__ ( self ) -> str : parent_repr = super () . __repr__ () if parent_repr == \" {} \" : parent_repr = \"\" return f \"SortExpression( { parent_repr } )\" odmantic . query . asc ( field ) \u00b6 Sort by ascending field . Source code in odmantic/query.py 138 139 140 def asc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by ascending `field`.\"\"\" return _build_sort_expression ( field , 1 ) odmantic . query . desc ( field ) \u00b6 Sort by descending field . Source code in odmantic/query.py 143 144 145 def desc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by descending `field`.\"\"\" return _build_sort_expression ( field , - 1 )","title":"odmantic.query"},{"location":"api_reference/query/#odmantic.query.QueryExpression","text":"Bases: Dict [ str , Any ] Base object used to build queries. All comparison and logical operators returns QueryExpression objects. The | and & operators are supported for respectively the or and the and logical operators. Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Source code in odmantic/query.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class QueryExpression ( Dict [ str , Any ]): \"\"\"Base object used to build queries. All comparison and logical operators returns `QueryExpression` objects. The `|` and `&` operators are supported for respectively the [or][odmantic.query.or_] and the [and][odmantic.query.and_] logical operators. Warning: When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. \"\"\" def __repr__ ( self ) -> str : parent_repr = super () . __repr__ () if parent_repr == \" {} \" : parent_repr = \"\" return f \"QueryExpression( { parent_repr } )\" def __or__ ( self , other : \"QueryExpression\" ) -> \"QueryExpression\" : return or_ ( self , other ) def __and__ ( self , other : \"QueryExpression\" ) -> \"QueryExpression\" : return and_ ( self , other )","title":"QueryExpression"},{"location":"api_reference/query/#logical-operators","text":"","title":"Logical Operators"},{"location":"api_reference/query/#odmantic.query.and_","text":"Logical AND operation between multiple QueryExpression objects. Source code in odmantic/query.py 40 41 42 def and_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **AND** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$and\" : elements })","title":"and_()"},{"location":"api_reference/query/#odmantic.query.or_","text":"Logical OR operation between multiple QueryExpression objects. Source code in odmantic/query.py 45 46 47 def or_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **OR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$or\" : elements })","title":"or_()"},{"location":"api_reference/query/#odmantic.query.nor_","text":"Logical NOR operation between multiple QueryExpression objects. Source code in odmantic/query.py 50 51 52 def nor_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **NOR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$nor\" : elements })","title":"nor_()"},{"location":"api_reference/query/#comparison-operators","text":"","title":"Comparison Operators"},{"location":"api_reference/query/#odmantic.query.eq","text":"Equality comparison operator. Source code in odmantic/query.py 71 72 73 def eq ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Equality comparison operator.\"\"\" return _cmp_expression ( field , \"$eq\" , value )","title":"eq()"},{"location":"api_reference/query/#odmantic.query.ne","text":"Inequality comparison operator (includes documents not containing the field). Source code in odmantic/query.py 76 77 78 def ne ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Inequality comparison operator (includes documents not containing the field).\"\"\" return _cmp_expression ( field , \"$ne\" , value )","title":"ne()"},{"location":"api_reference/query/#odmantic.query.gt","text":"Greater than (strict) comparison operator (i.e. >). Source code in odmantic/query.py 81 82 83 def gt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than (strict) comparison operator (i.e. >).\"\"\" return _cmp_expression ( field , \"$gt\" , value )","title":"gt()"},{"location":"api_reference/query/#odmantic.query.gte","text":"Greater than or equal comparison operator (i.e. >=). Source code in odmantic/query.py 86 87 88 def gte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than or equal comparison operator (i.e. >=).\"\"\" return _cmp_expression ( field , \"$gte\" , value )","title":"gte()"},{"location":"api_reference/query/#odmantic.query.lt","text":"Less than (strict) comparison operator (i.e. <). Source code in odmantic/query.py 91 92 93 def lt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than (strict) comparison operator (i.e. <).\"\"\" return _cmp_expression ( field , \"$lt\" , value )","title":"lt()"},{"location":"api_reference/query/#odmantic.query.lte","text":"Less than or equal comparison operator (i.e. <=). Source code in odmantic/query.py 96 97 98 def lte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than or equal comparison operator (i.e. <=).\"\"\" return _cmp_expression ( field , \"$lte\" , value )","title":"lte()"},{"location":"api_reference/query/#odmantic.query.in_","text":"Select instances where field is contained in sequence . Source code in odmantic/query.py 101 102 103 def in_ ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$in\" , sequence )","title":"in_()"},{"location":"api_reference/query/#odmantic.query.not_in","text":"Select instances where field is not contained in sequence . Source code in odmantic/query.py 106 107 108 def not_in ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is **not** contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$nin\" , sequence )","title":"not_in()"},{"location":"api_reference/query/#odmantic.query.match","text":"Select instances where field matches the pattern regular expression. Source code in odmantic/query.py 111 112 113 114 115 116 117 118 119 def match ( field : FieldProxyAny , pattern : Union [ Pattern , str ]) -> QueryExpression : \"\"\"Select instances where `field` matches the `pattern` regular expression.\"\"\" # FIXME might create incompatibilities # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not if isinstance ( pattern , str ): r = re . compile ( pattern ) else : r = pattern return QueryExpression ({ + field : r })","title":"match()"},{"location":"api_reference/query/#sort-helpers","text":"","title":"Sort helpers"},{"location":"api_reference/query/#odmantic.query.SortExpression","text":"Bases: Dict [ str , Literal [-1, 1]] Base object used to build sort queries. Source code in odmantic/query.py 122 123 124 125 126 127 128 129 class SortExpression ( Dict [ str , Literal [ - 1 , 1 ]]): \"\"\"Base object used to build sort queries.\"\"\" def __repr__ ( self ) -> str : parent_repr = super () . __repr__ () if parent_repr == \" {} \" : parent_repr = \"\" return f \"SortExpression( { parent_repr } )\"","title":"SortExpression"},{"location":"api_reference/query/#odmantic.query.asc","text":"Sort by ascending field . Source code in odmantic/query.py 138 139 140 def asc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by ascending `field`.\"\"\" return _build_sort_expression ( field , 1 )","title":"asc()"},{"location":"api_reference/query/#odmantic.query.desc","text":"Sort by descending field . Source code in odmantic/query.py 143 144 145 def desc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by descending `field`.\"\"\" return _build_sort_expression ( field , - 1 )","title":"desc()"},{"location":"api_reference/reference/","text":"odmantic . reference . Reference ( * , key_name = None ) \u00b6 Used to define reference fields. Parameters: Name Type Description Default key_name Optional [ str ] name of the Mongo key that stores the foreign key None Source code in odmantic/reference.py 4 5 6 7 8 9 10 11 12 13 14 def Reference ( * , key_name : Optional [ str ] = None ) -> Any : \"\"\"Used to define reference fields. Args: key_name: name of the Mongo key that stores the foreign key <!-- #noqa: DAR201 --> \"\"\" return ODMReferenceInfo ( key_name = key_name )","title":"odmantic.reference"},{"location":"api_reference/reference/#odmantic.reference.Reference","text":"Used to define reference fields. Parameters: Name Type Description Default key_name Optional [ str ] name of the Mongo key that stores the foreign key None Source code in odmantic/reference.py 4 5 6 7 8 9 10 11 12 13 14 def Reference ( * , key_name : Optional [ str ] = None ) -> Any : \"\"\"Used to define reference fields. Args: key_name: name of the Mongo key that stores the foreign key <!-- #noqa: DAR201 --> \"\"\" return ODMReferenceInfo ( key_name = key_name )","title":"Reference()"}]}